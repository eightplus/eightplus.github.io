<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Qt多线程之QtConcurrent::map()]]></title>
    <url>%2F2019%2F11%2F15%2F2019-11-15-qtconcurrent-map%2F</url>
    <content type="text"><![CDATA[QtConcurrent::map()、QtConcurrent::mapped()和QtConcurrent::mappedReduced()函数可以对一个序列中（如QList、QVector等）的项目并行地进行计算。 示例源码 qtconcurrent-map 开发库的安装$ sudo apt install qtbase5-dev qt5-qmake qtchooser qtscript5-dev qttools5-dev-tools qtbase5-dev-tools 示例源码的编译和运行123$ qmake$ make$ ./qtconcurrent-map-demo 示例代码分析要点QtConcurrent::map() 如果想直接修改一个序列，可以使用QtConcurrent::map()。这个函数会将作为参数传入的函数应用到容器中的每一项，对这些项进行就地修改，即QtConcurrent::map()的序列被直接修改。虽然QtConcurrent::map()不通过QFuture返回任何结果（map函数的返回值、返回类型没有被使用）但仍然可以使用QFuture和QFutureWatcher监控map的状态。map函数有两个参数，第一个是序列(如QList)，第二个参数是一个函数。它的作用就是同时用第二个参数来计算第一个参数中的每一个元素，且结果直接覆盖到元素中。示例代码中m_list的值由原来的(1, 3, 5, 7, 9)变成了(2, 4, 6, 8, 10)，函数my_fun1被调用了5次，且根据打印处理的线程id可以判断这5次调用都是在不同的线程中执行的，而且都和主进程的线程id不同： 123456789101112131415void my_fun1(int &amp;value)&#123; qDebug() &lt;&lt; &quot;run my_fun1 thread id:&quot; &lt;&lt; QThread::currentThreadId(); value += 1;&#125;void MainWindow::onMapBtnClicked()&#123; QList&lt;int&gt; m_list; m_list &lt;&lt; 1 &lt;&lt; 3 &lt;&lt; 5 &lt;&lt; 7 &lt;&lt; 9; QFuture&lt;void&gt; future = QtConcurrent::map(m_list, my_fun1); future.waitForFinished(); qDebug() &lt;&lt; &quot;m_list: &quot;&lt;&lt; m_list;&#125; QtConcurrent::mapped() QtConcurrent::mapped()函数与QtConcurrent::map()函数类似，区别在于QtConcurrent::mapped()函数接受一个输入序列和一个map函数，返回一个包含修改内容的新序列（即把计算结果放到了新的容器中），适用于进行数据处理后需要整理为新的数据结构的情况。 从如下的示例代码的运行结果中我们可以看到原容器的值没有发生改变，原容器的值为 (2, 4, 6, 8, 10)，修改后的新容器的值为(1, 3, 5, 7, 9)，函数my_fun2被调用了5次，且根据打印处理的线程id可以判断这5次调用都是在不同的线程中执行的，而且都和主进程的线程id不同： 12345678910111213141516int my_func2(int value)&#123; qDebug() &lt;&lt; &quot;run my_func2 thread id:&quot; &lt;&lt; QThread::currentThreadId(); return value - 1;&#125;void MainWindow::onMappedBtnClicked()&#123; QList&lt;int&gt; m_list; m_list &lt;&lt; 2 &lt;&lt; 4 &lt;&lt; 6 &lt;&lt; 8 &lt;&lt; 10; QFuture&lt;int&gt; future = QtConcurrent::mapped(m_list, my_func2); future.waitForFinished(); qDebug()&lt;&lt;&quot;m_list: &quot; &lt;&lt; m_list; qDebug()&lt;&lt;&quot;new list: &quot; &lt;&lt; future.results();&#125; 下面再介绍一段稍微复杂点的关于QtConcurrent::mapped()的代码片段，在加载多张照片的过程中，体现如何进行线程执行的进度、取消/暂停/恢复等。点击示例代码中的“打开”按钮时，调用槽函数onOpenBtnClicked()，默认打开图片目录进行图片选择。然后根据图片创建对应数量QLabel去显示缩放的图片，为了体现出一个耗时处理进度，我在代码图片缩放处理的过程中特意添加了sleep()，并添加了一个进度条。图片选择完成后，使用mapped()进行并行计算，并添加至QFutureWatcher中，让其使用信号和槽监视QFuture。当QFutureWatcher的progressRangeChanged()的信号触发时，进度条的范围会发生改变，而progressValueChanged()信号触发时，会更新进度条的值。如果加载的图片较多，可以通过点击“取消”按钮，这时会调用QFutureWatcher的cancel()槽函数来取消计算。“暂停/恢复”则调用togglePaused()槽函数，用于切换异步计算的暂停状态（如果计算当前已暂停，调用此函数将进行恢复；如果计算正在运行，则会暂停）。 12345678910111213141516171819202122232425262728293031323334353637383940414243void MainWindow::onOpenBtnClicked()&#123; if (m_watcher-&gt;isRunning()) &#123; m_watcher-&gt;cancel(); m_watcher-&gt;waitForFinished(); &#125; QStringList files = QFileDialog::getOpenFileNames(this, tr(&quot;Select Images&quot;), QStandardPaths::writableLocation(QStandardPaths::PicturesLocation), &quot;*.jpg *.png&quot;); if (files.isEmpty()) return; qDeleteAll(m_labels); m_labels.clear(); int dim = qSqrt(qreal(files.count())) + 1; for (int i = 0; i &lt; dim; ++i) &#123; for (int j = 0; j &lt; dim; ++j) &#123; QLabel *imageLabel = new QLabel; imageLabel-&gt;setFixedSize(imageSize,imageSize); m_imagesLayout-&gt;addWidget(imageLabel,i,j); m_labels.append(imageLabel); &#125; &#125; std::function&lt;QImage(const QString&amp;)&gt; image_scale = [imageSize](const QString &amp;imageName) &#123; //在线程中执行，所以线程id与主进程的不一样 static int count = 0; qDebug() &lt;&lt; &quot;run image_scale thread id:&quot; &lt;&lt; QThread::currentThreadId(); QImage image(imageName); count += 3; sleep(count); return image.scaled(QSize(imageSize, imageSize), Qt::IgnoreAspectRatio, Qt::SmoothTransformation); &#125;; auto future = QtConcurrent::mapped(files, image_scale); m_watcher-&gt;setFuture(future); m_openBtn-&gt;setEnabled(false); m_cancelBtn-&gt;setEnabled(true); m_pauseBtn-&gt;setEnabled(true);&#125; 当然，上面出现的image_scale()函数也可以写成如下格式： 1234567891011QImage image_scale(const QString &amp;imageName)&#123; //在线程中执行，所以线程id与主进程的不一样 static int count = 0; qDebug() &lt;&lt; &quot;run image_scale thread id:&quot; &lt;&lt; QThread::currentThreadId(); QImage image(imageName); count += 3; sleep(count); return image.scaled(QSize(imageSize, imageSize), Qt::IgnoreAspectRatio, Qt::SmoothTransformation);&#125; QtConcurrent::mappedReduced() QtConcurrent::mappedReduced()功能类似于mapped()，但它不是返回具有新结果的序列，它比mapped()多一个参数，这个参数也是个函数，它会将修改过的每一项再传入这个比mapped()多的参数函数中进行简化，将多个结果按某种要求简化成一个。mappedReduced函数遵循如下格式： V function(T &amp;result, const U &amp;intermediate)， 其中result就是最后的结果，intermediate就是mapped出来的结果。 从如下示例代码的运行结果中我们可以看到result的值为30,即将每个新值加起来的总和，函数my_sum(即称为reduce的函数)将由map函数返回的每个结果调用一次，并且应该合并中间体到结果变量。QtConcurrent::mappedReduced()可以保证保证一次只有一个线程调用reduce，所以没有必要用一个mutex锁定结果变量。QtConcurrent::ReduceOptions枚举提供了一种方法来控制reduction完成的顺序。如果使用了QtConcurrent::UnorderedReduce（默认），顺序是不确定的；而QtConcurrent::OrderedReduce确保reduction按照原始序列的顺序完成。示例中函数my_fun3()被调用了5次，且根据打印处理的线程id可以判断这5次调用都是在不同的线程中执行的，而且都和主进程的线程id不同，另外函数my_sum()也被调用了5次，但这五次的线程id一样，且和上面第一次执行函数my_func3的线程id一致。 12345678910111213141516171819202122int my_func3(int value)&#123; qDebug() &lt;&lt; &quot;run my_func3 thread id:&quot; &lt;&lt; QThread::currentThreadId(); return value * 2;&#125;void my_sum(int &amp;result, const int &amp;intermediate)&#123; qDebug() &lt;&lt; &quot;run my_sum thread id:&quot; &lt;&lt; QThread::currentThreadId(); result += intermediate;&#125;void MainWindow::onMappedReducedBtnClicked()&#123; QList&lt;int&gt; m_list; m_list&lt;&lt; 1 &lt;&lt; 2 &lt;&lt; 3 &lt;&lt; 4 &lt;&lt; 5; QFuture&lt;int&gt; future = QtConcurrent::mappedReduced(m_list, my_func3, my_sum); future.waitForFinished(); qDebug() &lt;&lt; &quot;result:&quot; &lt;&lt; future.result();//30&#125; 下面接着使用QtConcurrent::mappedReduced()来比较使用多线程和单线程处理的效率，示例代码片段的作用是统计用户主目录下所有的.cpp和.h文件中的单词数目，比较使用主线程计算和使用多线程并行计算的耗时，如果你的.cpp和.h文件数目够多，可以通过打印看出两者耗时的明显差距，并且在计算很多文件的过程中，使用主线程计算将会导致界面卡顿，而使用多线程将不会影响界面的event事件。 使用单线程计算 12345678910111213141516WordCount countWordsWithSingleThread(const QStringList &amp;files)&#123; WordCount wordCount; for (const QString &amp;file : files) &#123; QFile f(file); f.open(QIODevice::ReadOnly); QTextStream textStream(&amp;f); while (!textStream.atEnd()) &#123; const auto words = textStream.readLine().split(&apos; &apos;); for (const QString &amp;word : words) wordCount[word] += 1; &#125; &#125; return wordCount;&#125; 使用多线程并行计算 123456789101112131415161718192021222324252627282930313233343536373839404142WordCount countWordsWithMultiThreads(const QString &amp;file)&#123; WordCount wordCount; QFile f(file); f.open(QIODevice::ReadOnly); QTextStream textStream(&amp;f); while (!textStream.atEnd()) &#123; const auto words = textStream.readLine().split(&apos; &apos;); for (const QString &amp;word : words) wordCount[word] += 1; &#125; return wordCount;&#125;void reduceWordCounts(WordCount &amp;result, const WordCount &amp;w)&#123; QMapIterator&lt;QString, int&gt; i(w); while (i.hasNext()) &#123; i.next(); result[i.key()] += i.value(); &#125;&#125;void MainWindow::onMappedReducedBtn2Clicked()&#123; QStringList files = findAllFiles(&quot;/home/lixiang/work&quot;, QStringList() &lt;&lt; &quot;*.cpp&quot; &lt;&lt; &quot;*.h&quot;); // Single thread QTime time1; time1.start(); WordCount total1 = countWordsWithSingleThread(files); qDebug() &lt;&lt; &quot;Single thread find&quot; &lt;&lt; total1.size() &lt;&lt; &quot;words, Using &quot; &lt;&lt; time1.elapsed() / 1000.0 &lt;&lt; &quot;seconds&quot;; // Multi thread QTime time2; time2.start(); WordCount total2 = QtConcurrent::mappedReduced(files, countWordsWithMultiThreads, reduceWordCounts); qDebug() &lt;&lt; &quot;Multi thread find &quot; &lt;&lt; total2.size() &lt;&lt; &quot;words, Using &quot; &lt;&lt; time2.elapsed() / 1000.0 &lt;&lt; &quot;seconds&quot;;&#125;]]></content>
      <categories>
        <category>Linux 编程</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt多线程之QtConcurrent::run()]]></title>
    <url>%2F2019%2F11%2F13%2F2019-11-13-qtconcurrent-run%2F</url>
    <content type="text"><![CDATA[前面两篇文章，我们介绍了QThread多线程的使用方法，今天开始介绍QtConcurrent，QtConcurrent是一个名字空间, 包含了众多的高级API, 方便用户编写多线程程序，且不需要使用低级线程原语(如:互斥、读写锁、等待条件或信号量)。QtConcurrent返回一个QFuture对象（QFuture类没有继承QObject，该类代表了一个异步调用的结果，它介于QtConcurrent和QFutureWatcher之间进行工作），这个对象可以用来查询任务当前的执行进度、暂停、恢复、取消任务以及获得运算结果，但并非所有的QFuture对象都支持暂停或取消的操作，如本篇文章将要介绍的由QtConcurrent::run()返回的QFuture对象则不能取消，而由QtConcurrent::mappedReduced()返回的对象则是是可以执行取消的。QFutureWatcher通过信号槽来跟异步调用实现交互，即可以通过信号槽来监视线程的完成情况（QFuture的进度）, 并获取线程的返回值。QFuture让线程可以通过某个后期产生的结果来实现同步，这个结果可以是任何拥有默认构造函数和拷贝构造函数的类型，如果这个结果在调用其result(), resultAt(), 或者results()方法时还没有准备好，QFuture将会一直等，直到结果准备好为止。在编写代码时，可以通过isResultReadyAt()方法来检测结果是否准备好，可以用绑定信号resultReadyAt来获取线程的结果。对于QFuture对象需要准备多个结果的情况，调用resultCount()方法可以返回连续结果的数量即我们可以从0到resultCount()进行遍历操作。 示例源码 qtconcurrent-run 开发库的安装$ sudo apt install qtbase5-dev qt5-qmake qtchooser qtscript5-dev qttools5-dev-tools qtbase5-dev-tools 示例源码的编译和运行123$ qmake$ make$ ./qtconcurrent-run-demo 示例代码分析要点 示例代码中模拟耗时操作的doLongTimeWork()函数有两种写法，如下面代码所示，QFuture&lt;QList&gt;表示返回异步调用的结果，类型为QList，而QFuture比较特殊，它表示不返回异步调用的结果。任何QFuture对象都可以赋值或者拷贝给QFuture对象，QFuture对于结果数据不需要而只需要状态或者进度信息的情况比较有用。 写法一： 12345678void Worker::doLongTimeWork()&#123; QFutureWatcher&lt;QList&lt;CityInfo&gt;&gt; *watcher = new QFutureWatcher&lt;QList&lt;CityInfo&gt;&gt;(/*this*/); QFuture&lt;QList&lt;CityInfo&gt;&gt; future = QtConcurrent::run(this, &amp;Worker::loadDataFromFile);//开始异步调用，QtConcurrent::run()用于在另外的线程运行一个函数 connect(watcher, &amp;QFutureWatcher&lt;QList&lt;CityInfo&gt;&gt;::finished, this, &amp;Worker::onInitFinished); connect(watcher, &amp;QFutureWatcher&lt;QList&lt;CityInfo&gt;&gt;::resultReadyAt, this, &amp;Worker::onResultReadyAt); watcher-&gt;setFuture(future);&#125; 写法二： 12345678void Worker::doLongTimeWork()&#123; QFutureWatcher&lt;QList&lt;CityInfo&gt;&gt; *watcher = new QFutureWatcher&lt;QList&lt;CityInfo&gt;&gt;(/*this*/); QFuture&lt;QList&lt;CityInfo&gt;&gt; future = QtConcurrent::run(load_data_from_file);//开始异步调用，QtConcurrent::run()用于在另外的线程运行一个函数 connect(watcher, &amp;QFutureWatcher&lt;QList&lt;CityInfo&gt;&gt;::finished, this, &amp;Worker::onInitFinished); connect(watcher, &amp;QFutureWatcher&lt;QList&lt;CityInfo&gt;&gt;::resultReadyAt, this, &amp;Worker::onResultReadyAt); watcher-&gt;setFuture(future);&#125; 通过QFutureWatcher的resultReadyAt信号绑定槽函数的onResultReadyAt，我们可以知道线程已经将什么样的结果已经准备好了，而通过QFutureWatcher的finished信号，我们可以知道线程执行完毕了，并可以通过wather来获取线程的结果，如下两个函数： 12345678910111213141516171819202122232425262728void Worker::onResultReadyAt(int index)&#123; QFutureWatcher&lt;QList&lt;CityInfo&gt;&gt; *watcher = static_cast&lt;QFutureWatcher&lt;QList&lt;CityInfo&gt;&gt; *&gt;(sender()); if (!watcher) return; QList&lt;CityInfo&gt; info_list = watcher-&gt;resultAt(index); qDebug() &lt;&lt; &quot;length: &quot;&lt;&lt; info_list.length() &lt;&lt; &quot;, index: &quot; &lt;&lt; index &lt;&lt; &quot;, region:&quot; &lt;&lt; info_list.at(0).region;&#125;void Worker::onInitFinished()&#123; static int count = 0; qDebug() &lt;&lt; &quot;Worker::onInitFinished&quot;; QFutureWatcher&lt;QList&lt;CityInfo&gt;&gt; *watcher = static_cast&lt;QFutureWatcher&lt;QList&lt;CityInfo&gt;&gt; *&gt;(sender()); if (!watcher) return; m_cityInfos = watcher-&gt;result(); for (const auto &amp;info : m_cityInfos) &#123; //qDebug() &lt;&lt; &quot;region:&quot; &lt;&lt; info.region; &#125; watcher-&gt;deleteLater(); emit scanFinished(count++);&#125;]]></content>
      <categories>
        <category>Linux 编程</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt多线程之子类化QObject]]></title>
    <url>%2F2019%2F11%2F11%2F2019-11-11-qthread-object%2F</url>
    <content type="text"><![CDATA[上一篇文章讲述了子类化QThread，并重新实现run()函数，这篇文章将讲述多线程之定义工作对象继承自QObject，然后把这个工作对象move到QThread的一个对象中（moveToThread(QThread * thread)函数将工作类对象移到所创建的QThread对象中去执行），本方法巧妙的利用了Qt信号和槽机制，比如在UI主进程中想让线程执行一个耗时操作，这时候不是通过线程对象去直接调用继承于QObject的那个类的方法，而是通过信号槽绑定，UI主进程发送一个信号signal，继承于QObject的那个类的槽函数则是在新线程中执行了。同样，在示例代码中，通过打印的线程ID(QThread::currentThreadId())可以看出哪些代码在原线程中执行，哪些代码在新线程中执行。 示例源码 qthread-object 开发库的安装$ sudo apt install qtbase5-dev qt5-qmake qtchooser qtscript5-dev qttools5-dev-tools qtbase5-dev-tools 示例源码的编译和运行123$ qmake$ make$ ./thread-object-demo 大概步骤1. 在主线程中，创建一个QThread实例 2. 子类化QObject，把耗时操作封装到子类(示例代码的Worker类)槽函数中 3. 创建Worker实例，建立QThread实例与Worker实例之间的信号和槽关系 4. 调用Worker实例的moveToThread(QThread * thread)函数，将它移动到创建的QThread线程中去 5. 执行QThread线程的start()方法 示例代码分析要点 示例代码和上一篇文章的示例代码区别不大，代码很短，容易看懂，按钮点击后，发送了一个名为requestDoWork的信号，这个信号绑定到了Worker类的槽函数doLongTimeWork，那么doLongTimeWork()函数就是在新线程中执行了。示例代码中体现线程创建和move的代码如下： 12345678m_worker = new Worker();m_thread = new QThread();m_worker-&gt;moveToThread(m_thread);//移动worker对象实例到线程中connect(m_worker, SIGNAL(destroyed(QObject*)), m_thread, SLOT(quit()));//当worker对象实例销毁时，退出线程connect(m_thread, SIGNAL(finished()), m_thread, SLOT(deleteLater()));//当线程结束时，销毁线程对象实例connect(m_worker, &amp;Worker::sendCount, this, &amp;MainWindow::onResponseCount);connect(this, SIGNAL(requestDoWork()), m_worker, SLOT(doLongTimeWork()));m_thread-&gt;start();//启动线程]]></content>
      <categories>
        <category>Linux 编程</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt多线程之子类化QThread]]></title>
    <url>%2F2019%2F11%2F10%2F2019-11-10-qthread-run%2F</url>
    <content type="text"><![CDATA[Qt中提供了对于线程的支持，它提供了一些独立于平台的线程类QThread，要使用QThread进行多线程编程，有两种方式。一是子类化QThread，并重新实现run()函数；二是定义工作对象继承自QObject，然后把这个工作对象move到QThread的一个对象中。本文介绍第一种方法，在使用这种方法时，构造函数还是在原来的线程中执行，run()函数才在新的线程中执行，在示例代码中，通过打印的线程ID(QThread::currentThreadId())可以看出哪些代码在原线程中执行，哪些代码在新线程中执行。 示例源码 qthread-run 开发库的安装$ sudo apt install qtbase5-dev qt5-qmake qtchooser qtscript5-dev qttools5-dev-tools qtbase5-dev-tools 示例源码的编译和运行123$ qmake$ make$ ./qthread-demo 大概步骤1. 子类化QThread 2. 重载run函数，run函数内有一个forever或while或for的死循环（模拟耗时操作） 3. 设置一个标记为来控制死循环的退出 设置线程优先级- 通过start()设置，如：start(QThread::LowPriority)； - 通过setPriority(Priority priority)函数设置，这个函数设置正在运行线程的优先级，如果线程没有运行，此功能不执行任何操作并立即返回。 QThread::Priority枚举 值 描述 QThread::IdlePriority 0 没有其它线程运行时才调度 QThread::LowestPriority 1 比LowPriority调度频率低 QThread::LowPriority 2 比NormalPriority调度频率低 QThread::NormalPriority 3 操作系统默认的默认优先级 QThread::HighPriority 4 比NormalPriority调度频繁 QThread::HighestPriority 5 比HighPriority调度频繁 QThread::TimeCriticalPriority 6 尽可能频繁的调度 QThread::InheritPriority 7 使用和创建线程同样的优先级（默认值） 示例代码分析要点 示例代码主要为演示在run中执行耗时操作，如果想要耗时函数执行完成后发出通知，可以通过信号槽机制通知线程结束了，即发送一个信号。代码用到了QMutex和QWaitCondition。QMutex是强制执行互斥的基本类，一个线程锁定一个互斥量（mutex），以获得共享资源的访问权限，当互斥量已被锁定时，此时如果另一个线程试图锁定互斥量，则它将进入睡眠状态，直到第一个线程完成其任务并解锁互斥量。QWaitCondition同步线程，不通过执行互斥，而通过提供一个条件变量，QWaitCondition 使线程等待，直到满足一个特定的条件才让等待中的线程继续进行（其中QWaitCondition::wakeAll()唤醒所有在等待waitCondition的线程，这些线程被唤醒的顺序依赖于操组系统的调度策略，并且不能被控制或预知；QWaitCondition::wakeOne()唤醒一个随机的等待waitCondition的线程，线程的唤醒取决于操作系统的政策，不能被控制。） 如下函数doLongTimeWork()，里面构造了一个局部的QMutexLocker对象并锁住互斥量，当QMutexLocker被销毁的时候，互斥量将被自动解锁(因为QMutexLocker是个局部变量，当函数返回时它就被销毁)，当执行函数doLongTimeWork()时，如果线程未运行，则调用start()开启线程，如果线程已经在运行了，则调用condition.wakeOne()唤醒线程。 1234567891011void WorkerThread::doLongTimeWork()&#123; QMutexLocker locker(&amp;mutex); if (!isRunning()) &#123; start(QThread::LowPriority); &#125; else &#123; condition.wakeOne(); &#125;&#125; run()中的condition.wait(&amp;mutex)会让mutex会被暂时释放(会自动调用unlock解锁之前锁住的资源，避免造成死锁)，并阻塞在这个地方，当线程被cond.wakeOne()等唤醒时，mutex又会被重新锁定，并继续运行。 1234567891011121314void WorkerThread::run()&#123; static int count = 0; forever &#123; if (abort) return; mutex.lock(); //当处于wait状态时mutex会被暂时释放(会自动调用unlock解锁之前锁住的资源，避免造成死锁)，并阻塞在这个地方；当线程被cond.wakeOne()等唤醒时，mutex又会被重新锁定，并继续运行 this-&gt;loadDataFromFile(); emit sendCount(count++); condition.wait(&amp;mutex);//QWaitCondition 用于多线程的同步，一个线程调用QWaitCondition::wait() 阻塞等待，直到另一个线程调用QWaitCondition::wake() 唤醒才继续往下执行 mutex.unlock(); &#125;&#125; 注意QMutex与QWaitCondition区别： QMutex::lock相当于临界区锁，让处于锁中的资源不能被别的线程访问，即自己霸着不让别人用。 QWaitCondition::wait相当于互斥量锁，让线程等着，当别的线程访问完了，自己才能访问，即自己排队等着别人用完自己再用。]]></content>
      <categories>
        <category>Linux 编程</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt配置文件之QGSettings]]></title>
    <url>%2F2019%2F11%2F07%2F2019-11-07-qgsettings%2F</url>
    <content type="text"><![CDATA[本文介绍使用dconf作为后端的GSetting用法，dconf是一个简单的底层配置存储管理系统，可以使用图形化的dconf-editor根据path来检索GSettings并管理key，而且支持在key发生改变时发出通知(changed信号)。命令行工具gsettings提供了对GSetings的命令行操作，可以查询、读取和设置键值。如果你觉得glib、gio太复杂(查看GSettings的API文档可以使用工具devhelp)，那么使用Qt的QGSettings来操作gsetting将会让你备很轻松，而且代码的可读性将提升，本文提供的demo就是使用QGSettings来操作gsetting。 示例源码 示例代码简要展示了如何使用QGSettings进行配置文件的读和写，以及监控配置文件中key的变化，并将其他途径导致的key的变化的value更新到代码中。 qgsetting-demo 开发库的安装$ sudo apt install qtbase5-dev qt5-qmake qtchooser qtscript5-dev qttools5-dev-tools qtbase5-dev-tools libgsettings-qt-dev 示例源码的编译和运行注意：在Qt的工程文件.pro中，需要加入如下两行：12CONFIG += link_pkgconfigPKGCONFIG += gsettings-qt 12345$ sudo install -m 0644 qgsettings-demo.gschema.xml /usr/share/glib-2.0/schemas$ sudo glib-compile-schemas /usr/share/glib-2.0/schemas$ qmake$ make$ ./qsettings-demo 配置文件GSettings的配置文件是xml格式的，文件需以.gschema.xml结尾，一个配置文件里面可以包含多个schema，每个schema可由多个key组成（key是无法通过代码动态创建的）。详细说明如下： 字段 说明 id schema中的id在整个配置系统中是唯一的，否则在执行glib-compile-schemas时会忽略重复的id的开头通常使用与应用相关的域名。 path schema中的path必须是以/开头并且以/结尾，不能包含连续的/，path用于指定在storage中存储路径，可以与id不一致。 name key的名称，需要在此schema中唯一，name的值由小写字母、数字和-组成，并且开头必须是小写字母，不能以-结尾，也不能出现连续的-。 type key的类型，需要是GVariant支持的类型，除了可以使用基本的类型外，也可按照GVariant的方式组合类型。 default key的默认值 summary key的简单描述 description key的详细描述 在schema文件中，通常一个id对应一个固定的path，但也可不设置path，这样就是一个可重定位的schema，path两头必须都有/，否则会验证失败。但是需要注意如果没有指定path属性，则gsettings无法被dconf-editor读取。要想schema文件被GSettings使用，还需要借助编译器glib-compile-schemas将schema文件编译为二进制文件。GSettings读取XDG_DATA_DIRS下的glib-2.0/schemas路径，需要将schema文件放到环境变量XDG_DATA_DIRS/glib-2.0/schemas/路径下，一般为/usr/share/glib-2.0/schemas和/usr/local/share/glib-2.0/schemas。这里我们将qgsettings-demo.gschema.xml文件拷贝到/usr/share/glib-2.0/schemas路径下，然后执行如下一条命令将其编译刷新系统的gsettings中，否则使用的时候将报错并导致程序退出（Settings schema ‘apps.eightplus.qgsettings-demo’ is not installed）： 1$ sudo glib-compile-schemas /usr/share/glib-2.0/schemas gsettings命令 命令 说明 gsettings list-schemas 显示系统已安装的不可重定位的schema(已安装并已安装并有固定path的 schema)。 gsettings list-relocatable-schemas 显示已安装的可重定位的schema(已安装却没有固定path的 schema)。 gsettings list-children SCHEMA 显示指定schema的children，其中SCHEMA为xml文件中schema的id属性值，如示例代码中daemon的”apps.eightplus.qgsettings-demo”。 gsettings list-keys SCHEMA 显示指定schema的所有项(key)。 gsettings range SCHEMA KEY 查询指定schema的指定项KEY的有效取值范围。 gsettings get SCHEMA KEY 显示指定schema的指定项KEY的值。 gsettings set SCHEMA KEY VALUE 设置指定schema的指定项KEY的值为VALUE。 gsettings reset SCHEMA KEY 恢复指定schema的指定项KEY的值为默认值。 gsettings reset-recursively SCHEMA 恢复指定schema的所有key的值为默认值。 gsettings list-recursively [SCHEMA] 如果有SCHEMA参数，则递归显示指定schema的所有项(key)和值(value)，如果没有SCHEMA参数，则递归显示所有schema的所有项(key)和值(value)。 举例 查看apps.eightplus.qgsettings-demo是否已经安装 12lixiang@lixiang-TM1701:~$ gsettings list-schemas |grep apps.eightplus.qgsettings-demoapps.eightplus.qgsettings-demo 查看apps.eightplus.qgsettings-demo的schema下所有项的取值 1234lixiang@lixiang-TM1701:~$ gsettings list-recursively apps.eightplus.qgsettings-demoapps.eightplus.qgsettings-demo male falseapps.eightplus.qgsettings-demo age 22apps.eightplus.qgsettings-demo name &apos;lixiang&apos; 获取name的值 1gsettings get apps.eightplus.qgsettings-demo name 设置name的值 1gsettings set apps.eightplus.qgsettings-demo name kobe 恢复name的默认值 1gsettings reset apps.eightplus.qgsettings-demo name 恢复所有key的默认值 1gsettings reset-recursively apps.eightplus.qgsettings-demo 参考文档https://developer.gnome.org/GSettings/]]></content>
      <categories>
        <category>Linux 编程</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt配置文件之QSettings]]></title>
    <url>%2F2019%2F11%2F06%2F2019-11-06-qsettings%2F</url>
    <content type="text"><![CDATA[在用Qt编程时，很多时候需要在本地保留用户的配置，方便下次启动程序的时候使用上次的配置数据，这里推荐使用QSettings读写配置文件（QSettings可重入，即可以同时在不同的线程中使用不同的QSettings对象），而不是去用数据库去记录和读取这些数据（如轻量级数据库sqlite）。 示例源码 qsetting-demo 开发库的安装$ sudo apt install qtbase5-dev qt5-qmake qtchooser qtscript5-dev qttools5-dev-tools qtbase5-dev-tools 示例源码的编译安装和运行123$ qmake$ make$ ./qsettings-demo QSettings对象的创建 QSettings对象既可以创建在栈上，也可以创建在堆上，构建和销毁也非常快。QSettings类的构造函数的重载允许我们用各种方法来初始化QSettings对象，比如可以在当创建QSettings对象时，通过指定公司或组织名称以及产品名称，也可以通过指定文件路径和Format类型，这里我们介绍用指定文件路径和Format类型的方式构造QSettings对象。 - 栈上的对象 123QString filename = QDir::homePath() + &quot;/.config/eightplus/qsettings-demo.ini&quot;;QSettings m_settings(filename, QSettings::IniFormat);m_settings.setIniCodec(&quot;UTF-8&quot;); - 堆上的对象 123QString filename = QDir::homePath() + &quot;/.config/eightplus/qsettings-demo.ini&quot;;QSettings *m_settings = new QSettings(filename, QSettings::IniFormat);m_settings-&gt;setIniCodec(&quot;UTF-8&quot;); 其中，枚举类型Format的定义如下： 12345678910111213141516171819202122enum Format &#123; NativeFormat, IniFormat, InvalidFormat = 16, CustomFormat1, CustomFormat2, CustomFormat3, CustomFormat4, CustomFormat5, CustomFormat6, CustomFormat7, CustomFormat8, CustomFormat9, CustomFormat10, CustomFormat11, CustomFormat12, CustomFormat13, CustomFormat14, CustomFormat15, CustomFormat16&#125;; 在Linux上编程，我们介绍NativeFormat和IniFormat，对于我个人而已，我一直使用的是IniFormat。 常量 值 描述 QSettings::NativeFormat 0 使用平台最合适的存储格式设置。在Unix中，使用的是INI格式的文本配置文件。 QSettings::IniFormat 1 存储在INI文件中的设置。 QSettings存储 QSettings使用setValue()函数存储一系列设置，每个设置包括key（字符串）和一个与该key关联的value（QVariant），如： 123456m_settings-&gt;beginGroup(&quot;General&quot;);m_settings-&gt;setValue(&quot;name&quot;, m_name);m_settings-&gt;setValue(&quot;male&quot;, m_male);m_settings-&gt;setValue(&quot;age&quot;, m_age);m_settings-&gt;endGroup();m_settings-&gt;sync(); sync()：如果存在相同的key，现有的值将被新值覆盖。为了提高效率，这些变化可能不会被立即保存到永久存储（可以随时调用sync()来提交更改）。 QSettings读取 QSettings使用使用value()函数得到一个key的value，如： 12345678m_settings-&gt;beginGroup(&quot;General&quot;);m_name = m_settings-&gt;value(&quot;name&quot;, m_name).toString();if (m_name.isEmpty()) &#123; m_name = &quot;lixiang&quot;;&#125;m_male = m_settings-&gt;value(&quot;male&quot;, m_male).toBool();m_age = m_settings-&gt;value(&quot;age&quot;, m_age).toInt();m_settings-&gt;endGroup(); QVariant类型 QSettings的value为QVariant类型，Qvariant是一种数据类型的集合，是Qt Core模块的一部分，它支持大部分通常的Qt数据类型转换，如：toInt()，toString(), toBool()，toPoint()，toSize()等，但它不能提供Qt GUI那一部分的Qt数据类型转换，如：QColor、QImage、 QPixmap，即QVariant中没有toColor()、toImage()、toPixmap()等接口，此时可以使用QVariant::value()或qVariantValue()模板函数，如下所示： 1QColor color = m_settings-&gt;value(&quot;color&quot;).value&lt;QColor&gt;(); 既然上面说到QVariant中没有toColor()等接口，那如果是QColor等类型，是否可以直接用setValue()去存储呢？答案是可以的，包括Qt Core和Qt GUI在类的相关类型，QVariant都支持，如下所示： 12QColor color = palette().background().color();m_settings-&gt;setValue(&quot;color&quot;, color); 另外，使用qRegisterMetaType()和qRegisterMetaTypeStreamOperators()注册的自定义类型，也可以使用QSettings进行存储。 ini配置文件示范 1234[%General]age=18male=truename=lixiang]]></content>
      <categories>
        <category>Linux 编程</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过boost.python将c++封装成动态库供python调用]]></title>
    <url>%2F2019%2F10%2F22%2F2019-10-22-boost-python-cpp%2F</url>
    <content type="text"><![CDATA[这里简要介绍如何通过boost.python将c++封装动态库，让python直接调用库中的函数，要做到这一点，我们需要让so中将要在python中直接调用的函数、类、结构体等，通过boost中特定函数暴露给python，而且so的目标名必须和BOOST_PYTHON_MODULE使用的module名一致（即生成的动态库命名为封装模块的名字），这样，在python就可以直接import该模块，并像调用其他模块的函数、类、结构体等一样，直接调用里边的函数、类、结构体…… 示例源码 boost-python-cpp 开发库的安装$ sudo apt install libboost-dev libboost1.58-dev libboost-python-dev gcc g++ pkg-config python-dev build-essential 示例源码的编译安装和运行123$ make$ sudo make install$ python test.py C++封装动态库 如示例代码中daemon.cc中的代码所示，我们实现了一个类Daemon，该类的构造函数有一个string类型的参数，类中有两个成员函数detect_os_info和get_os_info，而且还在Deamon类之外实现了一个普通函数get_username。如下所示的BOOST_PYTHON_MODULE代码，目的是导出类及部分成员，以及普通函数，这些导出的类和函数，将可以在python中调用。 12345678BOOST_PYTHON_MODULE(boost_py_cpp_module)&#123; class_&lt;Daemon, boost::noncopyable &gt; (&quot;Daemon&quot;, &quot;This is the test daemon for python and C++&quot;, init&lt;std::string&gt;())//构造函数 .def(&quot;detect_os_info&quot;, &amp;Daemon::detect_os_info)//成员函数 .def(&quot;get_os_info&quot;, &amp;Daemon::get_os_info)//成员函数 ; def(&quot;get_username&quot;, &amp;get_username);//普通函数&#125; python调用C++ 示例中的test.py展示了python是如何调用C++中的类和函数，具体代码如下（其中 import boost_py_cpp_module就是导入C++编写的模块，该模块的名字与C++生成的库的名字一致）： 1234567891011121314151617181920212223242526import osimport sysimport ctypestry: libc = ctypes.CDLL(&apos;libc.so.6&apos;) libc.prctl(15, &apos;ydaemon&apos;, 0, 0, 0)except: passimport boost_py_cpp_moduledef get_os(): iface = boost_py_cpp_module.Daemon(&quot;OS&quot;) iface.detect_os_info() data = iface.get_os_info() return datadef get_username(): try: import boost_py_cpp_module username = boost_py_cpp_module.get_username() return username except: return &quot;root&quot;if __name__ == &apos;__main__&apos;: print &quot;OS info: &quot;, get_os() print &quot;User name: &quot;, get_username()]]></content>
      <categories>
        <category>Linux 编程</category>
      </categories>
      <tags>
        <tag>Boost Python C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Boost 序列化]]></title>
    <url>%2F2019%2F09%2F18%2F2019-09-18-boost-serialization%2F</url>
    <content type="text"><![CDATA[上一篇博客讲解过 protobuf 的序列化（将对象变成字节流的形式传出去）和反序列化（从字节流恢复成原来的对象），这篇博客将介绍另外一种序列化和反序列化的方案：Boost.Serialization。Boost.Serialization可以创建或重建程序中的等效结构，并保存为二进制数据、文本数据、XML或者有用户自定义的其他文件。 示例源码 boost-serialization protobuf 与 Boost.Serialization 的比较 protobuf:轻量级的，支持的数据类型有限，且数据对象必须预先定义，使用 protoc 编译，但其效率较高，适合要求效率，允许自定义类型的内部场合使用。 Boost.SerializationBoost 库非常庞大，功能丰富，Boost.Serialization序列化只是其中的一个小分支，但就算只使用序列化，也需要安装整个Boost库，其支持的序列化功能强大，既支持二维数组（指针），也支持STL容器，序列化使用灵活简。 Boost.Serialization 的两种模式介绍 Boost序列化可以分为两种模式：侵入式（intrusive）和非侵入式 （non-intrusive） 侵入式（intrusive） 侵入式序列化时，需要在class里面加入序列化的代码，序列化的步骤大致如下： 先引用 boost 头文件 在类的声明中, 编写序列化函数，该函数的格式如下: 12345template&lt;class Archive&gt;void serialize(Archive &amp; ar, const unsigned int version)//version是版本号&#123; ar&amp; m_str;&#125; 类的实例化和赋值 定义一个序列化的对象和数据流的写入(具体序列化和反序列化的代码见示例源码)123boost::archive::text_oarchive text_oa(text_sstream);//文本方式boost::archive::binary_oarchive binary_oa(binary_sstream);//二进制方式binary_oa &lt;&lt; info;//将对象info的序列化数据以二进制存储形式写入内存 非侵入式（non-intrusive） 如果class是早已存在的，且我们不想再改变class里面的代码时，这个时候，我们可以使用非侵入式的序列化。非侵入式序列化时，序列化函数需要访问数据成员，这就要求将class的数据成员暴露出来，即public，而不是private。其序列化的步骤和上面的侵入式序列化步骤一致。 Boost 开发库的安装$ sudo apt install libboost-dev libboost1.58-dev libboost-serialization1.58-dev]]></content>
      <categories>
        <category>Linux 编程</category>
      </categories>
      <tags>
        <tag>Boost</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[protobuf]]></title>
    <url>%2F2019%2F09%2F11%2F2019-09-11-protobuf%2F</url>
    <content type="text"><![CDATA[Protobuf: Google Protocol Buffer，是 Google 公司内部的混合语言数据标准，用于 RPC 系统和持续数据存储系统。 proto3 与 proto2 的区别 proto3 比 proto2 支持更多语言（如Go、Ruby、JavaNano等），去掉了一些复杂的语法和特性，更强调约定而弱化语法。下面列举几点 proto3 与 proto2 的不同点： 1、proto 文件开头第一行必须指定版本：syntax = &quot;proto3&quot;;，而在 proto2 中，可以写成 syntax = &quot;proto2&quot;; 或者不写； 2、字段规则移除了 “required”，将并把 “optional” 改名为 “singular”； 3、“repeated” 字段默认采用 packed 编码，而在 proto2 中，需要明确使用 [packed=true] 来为字段指定比较紧凑的 packed 编码方式； 4、移除了 default 选项，在 proto2 中，可以使用 default 选项为某一字段指定默认值，而在 proto3 中，字段的默认值只能根据字段类型由系统决定； 5、增加了 JSON 映射特性 …… protobuf编程 由于我的开发环境是Ubuntu 1604, 所以我这里编写示例代码将使用 proto2。protobuf是支持嵌套类型的，如下所示为 Protocol Buffers 官方文档提供的嵌套类型示例 Protocol Buffers 官方文档（proto文件添加注释和C/C++一样，使用 // 或 /* ... */语法） 123456789101112131415161718message Person &#123; required string name = 1; required int32 id = 2; optional string email = 3; enum PhoneType &#123; MOBILE = 0; HOME = 1; WORK = 2; &#125; message PhoneNumber &#123; required string number = 1; optional PhoneType type = 2 [default = HOME]; &#125; repeated PhoneNumber phone = 4;&#125; 示例代码将介绍两种语言的 protobuf 使用，C++和Python，对于C++，编译器会根据每个.proto文件生成一个.h和一个.cc文件，并为文件中描述的每种消息类型提供一个类。而对于Python则不同，Python编译器生成一个模块，其中包含每个消息类型的静态描述符，.proto然后与元类一起使用，以在运行时创建必要的Python数据访问类。 C++示例 源码 在动手编写代码之前，我们需要先安装编译依赖，执行如下命令： 1$ sudo apt install libprotobuf-dev protobuf-compiler C++ 示例代码的myinfo.proto文件的内容如下： 12345678syntax = &quot;proto2&quot;;package com.xiaoming.protobuf;message BufferMessage&#123; required int64 id = 1; required string name = 2; optional int32 opt = 3;&#125; 使用 protoc 命令根据 .proto 文件生成对应的 .pb.cc 和 .pb.h 文件，格式如下: protoc -I=输入目录 --cpp_out=输出目录 xxx.proto 比如执行protoc -I=./ --cpp_out=./ myinfo.proto则生成 myinfo.pb.cc 和 myinfo.pb.h。 源码中 test_in.c 的作用是序列化，并将序列化的内容写入文件中，而 test_out.c 的作用则是反序列化，读取 test_in.c 写入文件中的内容并反序列化。 具体编译情况见Makefile文件，编译和运行如下： 123make./test_in./test_out Python示例 源码 安装依赖，执行如下命令： 1$ sudo apt install python-protobuf Python 示例代码的myinfo.proto文件的内容如下（该文件根据上面提到的 Protocol Buffers 官方文档中提供的嵌套类型示例改写而来）： 12345678910111213141516171819202122232425syntax = &quot;proto2&quot;;package com.xiaoming.protobuf;message ClassMate&#123; required string name = 1; required int32 id = 2; optional string email = 3; enum PhoneType&#123; MOBILE = 0; HOME = 1; WORK = 2; &#125; message PhoneNumber&#123; required string number = 1; required PhoneType type = 2 [default = HOME]; &#125; repeated PhoneNumber phone = 4;&#125;message AlumniBook&#123; repeated ClassMate mate = 1;&#125; 使用 protoc 命令根据 .proto 文件生成对应的 .py 文件，格式如下: protoc -I=输入目录 --python_out=输出目录 xxx.proto 比如执行 protoc -I=./ --python_out=./ myinfo.proto 则生成 myinfo_pb2.py 文件。 源码中 test_in.py 的作用是序列化，并将序列化的内容写入文件中，test_out.py 的作用则是反序列化，读取 test_in.py 写入文件中的内容并反序列化。 运行命令如下： 12python test_in.py 1.logpython test_out.py 1.log]]></content>
      <categories>
        <category>Linux 编程</category>
      </categories>
      <tags>
        <tag>protobuf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回调函数]]></title>
    <url>%2F2019%2F09%2F05%2F2019-09-05-callback%2F</url>
    <content type="text"><![CDATA[为什么学会写回调函数很重要？ 假设有两个程序，程序A为上层应用程序，程序B为底层驱动接口，当底层驱动接口B有数据变化时需要将变化的数据传输给上层应用A时，此时有两种方式： 1)底层驱动接口B将变化的数据存放在接口函数中，上层应用A想调用的时候自己去调用B的接口获取变化的数据，即函数调用，此时主动权在上层应用A的手中。 2)底层驱动接口B实现回调机制，当有数据变化需要传输给上层应用A的时候通知A来读取变化的数据，然后上层应用A在用户层的回调函数中读取变化的数据。此时主动权在底层驱动接口B的手中。 我们知道，如果使用第一种方式，那么上层应用A根本就不知道底层驱动接口B中的数据在什么时候会发生变化，即不知道什么时候应该去调用底层驱动接口B的接口函数读取变化的数据；而使用第二种方式，上层应用A读取变化的数据的操作依赖于底层驱动接口B，只有底层驱动接口B呼叫上层应用A读该读取变化的数据了，上层应用A才会去读数据，即实现了中断读取。显然，在我们封装一些底层接口给别人使用的时候，实现回调函数将会派上很大的用场。 回调的定义和实现是怎样的？ 回调函数是指使用者自己定义一个函数，实现这个函数的程序内容，然后把这个函数（入口地址）作为参数传入别人的函数中，由别人的函数在运行时来调用的函数。即函数是你实现的，但由别人的函数在运行时通过参数传递的方式调用，这就是所谓的回调函数。 拿上面提到上层应用A和底层驱动接口B来打比方，也就是说回调函数是一个通过函数指针调用的函数。上层应用A把函数的指针（入口地址）作为参数传递给底层驱动接口B，当这个指针所指向的函数在底层驱动接口B中被调用时(即上层应用A不是自己调用这个函数，而是将这个函数的函数指针通过底层驱动接口B的接口函数传到底层驱动接口B中，由底层驱动接口B来操控执行)。 wiki上的介绍是这样的回调函数Callback)的： In computer programming, a callback, also known as a “call-after”what-is-a-callback-function function, is any executable code that is passed as an argument to other code that is expected to call back (execute) the argument at a given time. This execution may be immediate as in a synchronous callback, or it might happen at a later time as in an asynchronous callback. Programming languages support callbacks in different ways, often implementing them with subroutines, lambda expressions, blocks, or function pointers. 示例 这里提供一个简单的示例 test.c，演示了四个回调函数，回调函数processFunction的参数为一个结构体，回调函数test1Function的参数为一个整形变量，回调函数test2Function和test3Function的参数都为一个字符串，但这两个回调函数的用法不一样，一个使用别名方式，一个使用指针方式。 后续计划将Github上的callback示例进行更新，将其封装成一个so供用户程序调用。 源码：my-callback]]></content>
      <categories>
        <category>Linux 编程</category>
      </categories>
      <tags>
        <tag>callback</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gtk plugin 编程开发]]></title>
    <url>%2F2019%2F09%2F01%2F2019-09-01-gtk-plugins%2F</url>
    <content type="text"><![CDATA[前面介绍过GLib、GObject和Dbus-glib，这里将在这些知识的基础上，结合Gtk图形库，完成一个插件（plugin）框架的搭建。该怎么通俗易懂的介绍这里的插件呢，左思右想，还是决定以GStreamer为例来简单介绍下插件（GStreamer是一个创建流媒体应用程序的框架，这家伙对于Linux下的音/视频播放、摄像头等方面有着很重要的地位和作用，如 GNOME 桌面的默认播放器rhythmbox，cheese摄像头等软件都是用的GStreamer。我本人啊，对这个东西真的是特别感兴趣，可惜目前业余时间恐怕难以深入分析，遗憾:cold_sweat:）。 GStreamer 插件的工作原理同其他的基于插件的程序的工作原理类似，本质上都是通过读取动态库实现的，只需要每个动态库都实现某一个特定的接口就可以了，里面会有个像注册表一样的数据结构会存储所有的插件的信息。GStreamer 框架基于插件，有些插件中提供了各种各样的多媒体数字信号编解码器,也有些提供了其他的功能，所有的插件都能够被链接到任意的已经定义了的数据流管道中。元件是 GStreamer的核心，在 GStreamer 插件的开发中，一个元件就是继承于 GstElement 的一个对象，元件在与其他元件连接时提供了如下一些功能，比如：一个源元件为一个流提供数据，一个滤镜元件对流中的数据进行操作，也就是说没有了元件，GStreamer只是一堆概念性的管道，没有任何东西可供连接 。GStreamer 自带了一大堆元件，但我们也可以编写额外的元件，但仅仅编写新的元件并不够，为了使 GStreamer 能够使用它，就需要将元件封装到插件中。一个插件是一块可以加载的代码，通常被称为共享对象文件（shared object file）或动态链接库（dynamically linked library）。 说到这里，想必大家在概念上对插件有了初步认识。在编程方面，说到底就是插件可以让其他开发者在你的程序框架下开发更多的功能模块，而他们并不需要修改你的主程序，甚至不用怎么花心思去分析你的主程序。这样，你只需要编写一个框架，并提供一个插件示例，别人就能按照你的插件示例来编写其他插件，帮你的框架程序添砖加瓦，想想都轻松啊:laughing::laughing::laughing: 示例源码 my-plugin-daemon 示例代码编程要点简析编译相关介绍 安装编译依赖 $ sudo apt install autotools-dev intltool libpolkit-agent-1-dev libpolkit-gobject-1-dev libdbus-glib-1-dev libdconf-dev libglib2.0-dev libgtk-3-dev mate-common 编译和运行 这里不是直接使用automake，而是使用mate-common提供的mate-autogen，比较方便，具体见 autogen.sh 文件，编译和运行命令如下所示： 123$ ./autogen.sh --prefix=/usr$ make$ ./src/my-plugin-daemon --debug deb包 具体见源码目录下debian文件夹里面的内容，这里不做过多描述，有问题的话，可以向我发邮件寻求帮助。deb包的指针可以使用命令 debuild 或者 dpkg-buildpackage -rfakerooot -b，相关命令执行如下所示： 123$ debuild$ sudo dpkg -i ../my-plugin-daemon_1.0.0_amd64.deb$ /usr/bin/my-plugin-daemon 查看包安装的文件列表 123456789101112131415161718192021$ dpkg -L my-plugin-daemon/./usr/usr/share/usr/share/doc/usr/share/doc/my-plugin-daemon/usr/share/doc/my-plugin-daemon/changelog.gz/usr/share/glib-2.0/usr/share/glib-2.0/schemas/usr/share/glib-2.0/schemas/org.freedesktop.MyPluginDaemon.plugins.diskmonitor.gschema.xml/usr/include/usr/include/my-plugin-daemon/usr/include/my-plugin-daemon/my_daemon_client.h/usr/include/my-plugin-daemon/my_plugin.h/usr/bin/usr/bin/my-plugin-daemon/usr/lib/usr/lib/x86_64-linux-gnu/usr/lib/x86_64-linux-gnu/my-plugin-daemon/usr/lib/x86_64-linux-gnu/my-plugin-daemon/libdiskmonitor.so/usr/lib/x86_64-linux-gnu/my-plugin-daemon/diskmonitor.my-plugin 主框架的搭建 相关代码见源码目录下src，文件列表如下： 1234567891011main.cMakefile.ammy_daemon.cmy_daemon.hmy_module.cmy_module.hmy_plugin.cmy_plugin.hmy_plugin_info.cmy_plugin_info.horg.freedesktop.myplugindaemon.xml dbus server 在org.freedesktop.myplugindaemon.xml文件中，写了两个method和两个signal，start和stop分别表示启动插件加载和停止插件功能。PluginActivated和PluginDeactivated分别发送插件激活和停止的消息。这里注意下&lt;annotation name=&quot;org.freedesktop.DBus.GLib.CSymbol&quot; value=&quot;my_daemon&quot;/&gt;的value值，这个值表示通过工具dbus-binding-tool生成的绑定文件中callback相关的dbus_glib_marshal_xxx_BOOLEAN__POINTER中的xxx即为这个value值，不要将其和method的前缀混淆了，method的前缀是由dbus-binding-tool工具执行时”–prefix”参数指定的，生成的绑定文件中和前缀相关的代码如下所示： 1234static const DBusGMethodInfo dbus_glib_my_daemon_methods[] = &#123;&#123; (GCallback) my_daemon_start, dbus_glib_marshal_my_daemon_BOOLEAN__POINTER, 0 &#125;,&#123; (GCallback) my_daemon_stop, dbus_glib_marshal_my_daemon_BOOLEAN__POINTER, 40 &#125;,&#125;; 这里定义了一个存放私有变量的结构体，需要定义一个配合这个结构体的宏MY_DAEMON_GET_PRIVATE(o) ，而且在类结构的构造函数中增加一句g_type_class_add_private(klass, sizeof(MyDaemonPrivate));，结构体变量如下所示： 12345struct MyDaemonPrivate&#123; DBusGConnection *connection; GSList *plugins;&#125;; plugins manager 加载插件 从存放插件so的路径下读取so，读取插件对应的配置信息文件，绑定插件的信号，并将插件变量保存到上面提到的存放私有变量的结构体MyDaemonPrivate中的plugins中，方便对插件进行管理。 卸载插件 一是调用插件的停止工作模块，二是清空存放私有变量的结构体MyDaemonPrivate中plugins中的插件变量。 编写插件 这里就不对代码进行分析了，只简述下几个注意事项，相关代码见源码目录下src，文件列表如下： 12345678diskmonitor.my-plugin.inmy_diskmonitor_dialog.cmy_diskmonitor_plugin.cmy_diskmonitor_space.cMakefile.ammy_diskmonitor_dialog.hmy_diskmonitor_plugin.hmy_diskmonitor_space.h 这里的设想是这样的，建立了一个plugins目录，里面存放各个插件的代码，每一个插件都作为一个子目录存在。所以，在plugins目录下需要编写Makefile.am文件，方便在源码编译时管理旗下各个插件子目录。同样，子目录里面的插件要编译，也需要各自写一饿Makefile.am。当然，写了Makefile.am，就要对应的编写其输出的Makefile的规则，否则编不出Makefile文件，拿什么来make呢，是吧。我们在configure.ac文件的 AC_OUTPUT 下增加plugins/Makefile和plugins/diskmonitor/Makefile，其中diskmonitor就是我示例代码的一个插件。configure.ac文件中AC_OUTPUT的具体详情如下所示： 1234567AC_OUTPUT([Makefilesrc/Makefileplugins/Makefileplugins/diskmonitor/Makefilepo/Makefile.in]) 在编译插件so的时候，终端会显示出一个警告，大致如下： 1dpkg-shlibdeps: 警告: debian/my-plugin-daemon/usr/lib/x86_64-linux-gnu/my-plugin-daemon/libdiskmonitor.so contains an unresolvable reference to symbol my_plugin_get_type: it&apos;s probably a plugin 出现了这种情况的时候，我们不必担心插件除了什么问题，这仅仅是dpkg shlibdeps分析二进制使用符号集时的一个警告，具体详情可以查阅 dpkg-shlibdeps。 在data目录下，我对插件diskmonitor增加了一个org.freedesktop.MyPluginDaemon.plugins.diskmonitor.gschema.xml.in文件，该文件是schemas配置文件，该文件在安装deb包后存放的最终路径为：/usr/share/glib-2.0/schemas/org.freedesktop.MyPluginDaemon.plugins.diskmonitor.gschema.xml，里面我只放了一个参数active，默认为true，意思是插件diskmonitor默认处于激活状态，插件管理模块在加载插件的时候将会读取这个值，用户可以随时更改该值，已达到控制该插件启用和停止的目地。修改schemas配置文件的值时，除了可以用gsettings api提供的函数，如g_settings_get_string、g_settings_set_string外，还可以使用gsettings命令，具体参照 gsettings，当然还有更简单方便的办法，用图形工具 dconf-editor 来操作，如下所示： 1$ dconf-editor 最后再提一个plugin最重要的点，在插件管理模块中的四个文件my_plugin.c、my_plugin.h、my_module.c和my_module.h非常关键，这四个文件关系着插件真在的加载、卸载和导入。 1. my_plugin.h文件下有一个宏MY_PLUGIN_REGISTER，具体如下： 123456789101112#define MY_PLUGIN_REGISTER(PluginName, plugin_name) \ G_DEFINE_DYNAMIC_TYPE (PluginName, \ plugin_name, \ MY_TYPE_PLUGIN) \ \G_MODULE_EXPORT GType \register_my_plugin(GTypeModule *type_module) \&#123; \ plugin_name##_register_type(type_module); \ \ return plugin_name##_get_type(); \&#125; 2. my_module.c下有真在执行插件加载和卸载的两个函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849static gboolean my_module_load(GTypeModule *gmodule)&#123; MyModule *module; MyModuleRegisterFunc register_func; gboolean res; module = MY_MODULE(gmodule); g_debug(&quot;Loading %s&quot;, module-&gt;path); module-&gt;library = g_module_open(module-&gt;path, 0); if (module-&gt;library == NULL) &#123; g_warning (&quot;%s&quot;, g_module_error()); return FALSE; &#125; /* extract symbols from the lib */ res = g_module_symbol(module-&gt;library, &quot;register_my_plugin&quot;, (void *)&amp;register_func); if (!res) &#123; g_warning(&quot;%s&quot;, g_module_error()); g_module_close(module-&gt;library); return FALSE; &#125; g_assert(register_func); module-&gt;type = register_func(gmodule); if (module-&gt;type == 0) &#123; g_warning(&quot;Invalid my plugin in module %s&quot;, module-&gt;path); return FALSE; &#125; return TRUE;&#125;static void my_module_unload (GTypeModule *gmodule)&#123; MyModule *module = MY_MODULE(gmodule); g_debug(&quot;Unloading %s&quot;, module-&gt;path); g_module_close(module-&gt;library); module-&gt;library = NULL; module-&gt;type = 0;&#125; 3. 在每个插件的代码中都需要将my_plugin.h头文件include进来，且需要编写上面提到的插件宏MY_PLUGIN_REGISTER相关的register_my_plugin代码，如下所示： 1G_MODULE_EXPORT GType register_my_plugin(GTypeModule *module);]]></content>
      <categories>
        <category>Linux 编程</category>
      </categories>
      <tags>
        <tag>Gtk GLib GObject</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GObject 编程入门]]></title>
    <url>%2F2019%2F08%2F30%2F2019-08-30-gobject-demo%2F</url>
    <content type="text"><![CDATA[Gobject，也称Glib对象系统，是一个程序库，它可以帮助我们使用C语言编写面向对象程序，其提供了一个通用的动态类型系统（GType）、一个基本类型的实现集（如整型、枚举等）、一个基本对象类型Gobject、一个信号系统以及一个可扩展的参数/变量体系。在 GObject世界里，类是两个结构体的组合，一个是实例结构体，另一个是类结构体。GOBJECT的继承需要实现实例结构体的继承和类结构体的继承，Gobject对象的初始化可分为两个部分：类结构体初始化和实例结构体初始化。类结构体初始化函数只被调用一次，而实例结构体的初始化函数的调用次数等于对象实例化的次数。这意味着，所有对象共享的数据，可保存在类结构体中，而所有对象私有的数据，则保存在实例结构体中。 示例源码 gobjectdemo GObject编程要点简析 宏 如果你浏览过使用 gobject 编写的软件源代码，你对下面出现的宏一定不会陌生。 123456789#define MY_TYPE_DEMO (my_demo_get_type())#define MY_DEMO(object) G_TYPE_CHECK_INSTANCE_CAST((object), MY_TYPE_DEMO, MyDemo)#define MY_DEMO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass), MY_TYPE_DEMO, MyDemoClass))#define MY_IS_DEMO(object) G_TYPE_CHECK_INSTANCE_TYPE((object), MY_TYPE_DEMO))#define MY_IS_DEMO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass), MY_TYPE_DEMO))#define MY_DEMO_GET_CLASS(object) (G_TYPE_INSTANCE_GET_CLASS((object), MY_TYPE_DEMO, MyDemoClass))GType my_demo_get_type(void) G_GNUC_CONST;G_DEFINE_TYPE (MyDemo, my_demo, G_TYPE_OBJECT); 这里对上面的宏不作过多阐述，简要介绍下 MY_DEMO 和 G_DEFINE_TYPE。 MY_DEMO(object)宏的作用是将一个基类指针类型转换为 MyDemo 类的指针类型，它需要 GObject 子类的设计者提供。 my_demo_get_type将会使用宏G_DEFINE_TYPE去实现，其中的my通常表示命名空间，demo表示对象名字，get_type为固定字段(这里提到的my和demo字段都是我的示例代码使用的，你可以自定义)。G_DEFINE_TYPE 可以让 GObject 库的数据类型系统能够识别我们所定义的 MyDemo 类类型，它接受三个参数，第一个参数是类名，即 MyDemo，第二个参数则是类的成员函数名称的前缀，例如 my_demo_get_type 函数即为 MyDemo 类的一个成员函数，”my_demo”是它的前缀，第三个参数则指明 MyDemo 类类型的父类型为G_TYPE_OBJECT。G_DEFINE_TYPE中会调用一个 g_type_register_static_simple 的函数，这个函数的作用就是将用户自己定义的类型注册到系统中，G_DEFINE_TYPE还定义了2个函数（my_demo_init 和 my_demo_class_init），需要自己实现这两个函数，这两个函数是对象的初始化函数，相当于c++的构造函数，其中第一个函数在每个对象创建的时候都会被调用，第二个函数只有在第一次创建对象的时候被调用(比如在调用g_type_class_ref的时候，如果class没有初始化，就会调用my_demo_class_init)。当然这里也可以直接使用，而是使用的实现代码，见示例代码中被注释的那一大段代码。在gobject的手册中也有相关代码的示例，如下所示（G-DEFINE-TYPE）： 123456789101112131415161718192021222324252627282930313233static void gtk_gadget_init (GtkGadget *self);static void gtk_gadget_class_init (GtkGadgetClass *klass);static gpointer gtk_gadget_parent_class = NULL;static void gtk_gadget_class_intern_init (gpointer klass)&#123; gtk_gadget_parent_class = g_type_class_peek_parent (klass); gtk_gadget_class_init ((GtkGadgetClass*) klass);&#125;GTypegtk_gadget_get_type (void)&#123; static volatile gsize g_define_type_id__volatile = 0; if (g_once_init_enter (&amp;g_define_type_id__volatile)) &#123; GType g_define_type_id = g_type_register_static_simple (GTK_TYPE_WIDGET, g_intern_static_string (&quot;GtkGadget&quot;), sizeof (GtkGadgetClass), (GClassInitFunc) gtk_gadget_class_intern_init, sizeof (GtkGadget), (GInstanceInitFunc) gtk_gadget_init, 0); &#123; const GInterfaceInfo g_implement_interface_info = &#123; (GInterfaceInitFunc) gtk_gadget_gizmo_init &#125;; g_type_add_interface_static (g_define_type_id, TYPE_GIZMO, &amp;g_implement_interface_info); &#125; g_once_init_leave (&amp;g_define_type_id__volatile, g_define_type_id); &#125; return g_define_type_id__volatile;&#125; 对象实例化 1234gpointerg_object_new (GType object_type, const gchar *first_property_name, ...); g_object_new进行对象的实例化，这个函数是个可变参数的函数, 第一个参数为一个宏，是需要创建的对象的类型，当使用 g_object_new 来创建对象的时候, 这个参数是必须的，而且这个函数所创建的对象必须是GObject的子对象，在我们定义自己的对象时, 必须要在glib系统中注册自己的类型。后面的参数都是 “属性名-属性值” 的配对，即从第二个参数开始, 表示的是 object 的属性, 它们都是成对出现的，如果没有属性需要在创建对象的时候设置, 则第二个参数设置成 NULL（g_object_new(MY_TYPE_DEMO, NULL)），如果有属性要设置, 那么最后一个参数也要设置成 NULL（g_object_new(MY_TYPE_DEMO, &quot;name&quot;, &quot;kobe&quot;, &quot;age&quot;, 24, NULL)）。 属性如果想 让g_object_new 函数中通过 “属性名-属性值” 结构为 Gobject 子类对象的属性进行初始化，需要完成以下工作： 实现xx_xx_set_property与xx_xx_get_property函数，如示例代码中的my_demo_set_property和my_demo_get_property，完成 g_object_new 函数 “属性名-属性值” 结构向Gobject子类属性的映射； 在Gobject子类的类结构体初始化函数中，让Gobject基类的两个函数指针set_property与get_property分别指向xx_xx_set_property与xx_xx_get_property,如示例代码中的object_class-&gt;set_property = my_demo_set_property和object_class-&gt;get_property = my_demo_get_property; 在Gobject子类的类结构体初始化函数中，为Gobject子类安装具体对象的私有属性，g_object_class_install_property 函数用于将 GParamSpec 类型变量所包含的数据插入到 GObject 子类中，该函数的第一个参数为 GObject 子类的类结构体，第二个参数是 GParamSpec 对应的属性 ID，GObject 子类的属性 ID 是 GObject 子类设计者定义的宏或枚举类型，不能为0，所以在使用枚举类型来定义 ID 时，为了避免 0 的使用，一般设计如下所示的一个枚举类型，其中PROP_0为0,不使用。 1234567enum&#123; PROP_0, PROP_NAME, PROP_AGE, N_PROPERTIES&#125;; g_object_class_install_property的第三个参数是要安装值向 GObject 子类中的 GParamSpec 类型的变量指针，示例代码中的如下： 123456789101112131415g_object_class_install_property(object_class, PROP_NAME, g_param_spec_string(&quot;name&quot;, &quot;name&quot;, &quot;Specify the name of demo&quot;, &quot;Unknown&quot;, G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));g_object_class_install_property(object_class, PROP_AGE, g_param_spec_int64 (&quot;age&quot;, &quot;age&quot;, &quot;Specify age number&quot;, G_MININT64, G_MAXINT64, 0, G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY)); 其中获取和设置属性的具体实现代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344static void my_demo_set_property(GObject *object, guint prop_id, const GValue *value, GParamSpec *pspec)&#123; MyDemo *self; g_return_if_fail(object != NULL); self = MY_DEMO (object); //self-&gt;priv = MY_DEMO_GET_PRIVATE(self); switch (prop_id) &#123; case PROP_NAME: self-&gt;priv-&gt;name = g_value_dup_string(value); break; case PROP_AGE: self-&gt;priv-&gt;age = g_value_get_int64(value); break; default: G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec); break; &#125;&#125;static void my_demo_get_property(GObject *object, guint prop_id, GValue *value, GParamSpec *pspec)&#123; MyDemo *self; g_return_if_fail(object != NULL); self = MY_DEMO(object); switch (prop_id) &#123; case PROP_NAME: g_value_set_string(value, self-&gt;priv-&gt;name); break; case PROP_AGE: g_value_set_int64(value, self-&gt;priv-&gt;age); break; default: G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec); break; &#125;&#125; 当然，我们也可以通过g_object_get_property 和 g_object_set_property 获取和设置属性，如下所示： 12345GValue val = &#123;0&#125;; g_value_init(val, G_TYPE_POINTER);g_object_get_property(G_OBJECT(demo), &quot;name&quot;, val);g_object_set_property(G_OBJECT(demo), &quot;name&quot;, val);g_value_unset(val); 信号 使用 GObject 信号机制，一般有三个步骤： 信号注册 g_signal_new，主要解决信号与数据类型的关联问题 1234567891011int signal_id = g_signal_new(&quot;broadcast_msg&quot;, my_demo_get_type(),/*G_OBJECT_CLASS_TYPE(kclass)*/ G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE,/*返回值，因为信号没有返回，所以为NONE*/ 1,/*参数数目*/ G_TYPE_STRING/*参数类型*/ ); 信号连接 1234567void handler_receive_msg(GObject *sender, char *name, gpointer data)&#123; MyDemo *demo = G_TYPE_CHECK_INSTANCE_CAST(sender, my_demo_get_type(), MyDemo); printf(&quot;handler: [%s] from [%s: %ld]\n&quot;, name, demo-&gt;priv-&gt;name, demo-&gt;priv-&gt;age);&#125;g_signal_connect(demos[i], &quot;broadcast_msg&quot;, G_CALLBACK(handler_receive_msg), NULL); 信号发射 1g_signal_emit_by_name(demos[i], &quot;broadcast_msg&quot;, &quot;lixiang&quot;);]]></content>
      <categories>
        <category>Linux 编程</category>
      </categories>
      <tags>
        <tag>Glib GObject</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dbus-glib]]></title>
    <url>%2F2019%2F08%2F27%2F2019-08-27-dbus-glib%2F</url>
    <content type="text"><![CDATA[如果你想在Linux系统下开发软件，且需要用到进程间通信时，我强烈建议你了解和使用Dbus。Dbus是实质上一个适用于桌面应用的进程间的通讯机制，即所谓的IPC机制。Dbus是一个进程间的通信机制，可以是应用与应用之间的通信，也可以是应用与系统之间的通信，其提供了一个低时延、低消耗的IPC通讯，因为它采用了二进制的数据交换协议，不需要转换成文本化的数据进行交换，DBUS提供了面向多重对象系统的包装，可以在原有的面向对象的应用框架下使用DBUS，不需要学习新的概念和规范等。DBUS_BUS_SYSTEM（system Dbus）用于系统通讯、监控系统更新事件，DBUS_BUS_SESSION （session Dbus）用于多个桌面应用之间相互通讯。 Dbus-glib是GNU标准库，在Dbus接口上封装，方便上层服务与应用更好的使用。其形如一个Dbus代理服务器，由它进行所有Dbus消息的遍历与转发，服务端与消息发送端只需要向dbus deamon申请注册唯一的dbus name 、绑定GOBJECT后，dbus deamon就会将申请连到到该dbus name的Dbus信息转发给指定应用。dbus daemon不对消息重新排序，如果发送了两条消息到同一个进程，它们将按照发送顺序接受到。接受进程并需要按照顺序发出应答消息，例如在多线程中处理这些消息，应答消息的发出是没有顺序的。消息都有一个序列号可以与应答消息进行配对。 glib绑定接口在libdbus-glib-1-dev中定义，详情见：/usr/include/dbus-1.0/dbus/dbus-glib.h，dbus的接口描述文件统一采用utf-8编码。 表一 dbus和glib的数据类型映射表 D-Bus type Description GType C typedef Free function Notes a （ARRAY） 数组 数组元素的类型由a后面的标记决定。如：”as”是字符串数组，具体见表二表三 b （BOOLEAN） 布尔值 G_TYPE_BOOLEAN d （DOUBLE） IEEE 754双精度浮点数 G_TYPE_DOUBLE g （SIGNATURE） 类型签名 i （INT32） 32位有符号整数 G_TYPE_INT Will be changed to a G_TYPE_INT32 once GLib has it n （INT16） 16位有符号整数 G_TYPE_INT Will be changed to a G_TYPE_INT16 once GLib has it o （OBJECT_PATH ） 对象路径 DBUS_TYPE_G_PROXY g_object_unref The returned proxy does not have an interface set; use dbus_g_proxy_set_interface to invoke methods q （UINT16） 16位无符号整数 G_TYPE_UINT Will be changed to a G_TYPE_UINT16 once GLib has it s （STRING） 零结尾的UTF-8字符串 G_TYPE_STRING char * g_free t （UINT64） 64位无符号整数 G_TYPE_GUINT64 u （UINT32） 32位无符号整数 G_TYPE_UINT Will be changed to a G_TYPE_UINT32 once GLib has it v （VARIANT） 容器 G_TYPE_VALUE GValue * g_value_unset 可放任意数据类型的容器，数据中包含类型信息。如glib中的GValue x （INT64） 64位有符号整数 G_TYPE_GINT64 y （BYTE） 8位无符号整数 G_TYPE_UCHAR t （UINT64） 64位无符号整数 () 定义结构时使用。例如”(i(ii))” {} 定义键－值对时使用。例如”a{us}” 数组”a(i(ii))”的元素是一个结构。用括号将成员的类型括起来就表示结构了，结构可以嵌套。 数组”a{sv}”的元素是一个键－值对。”{sv}”表示键类型是字符串，值类型是VARIANT。 dbus数据也有包容器类型，像DBUS_TYPE_ARRAY 和 DBUS_TYPE_STRUCT，dbus的数据类型可以是嵌套的，如有一个数组，内容是字符串的数组集合。但并不是所有的类型都有普通的使用，DBUS_TYPE_STRUCT应该可以包容非基本类型的数据类型。glib绑定尝试使用比较明显的方式进行声明。 表二 数组表 D-Bus type signature Description GType C typedef Free function ay Array of bytes DBUS_TYPE_G_BYTE_ARRAY GArray * g_array_free au Array of uint DBUS_TYPE_G_UINT_ARRAY GArray * g_array_free ai Array of int DBUS_TYPE_G_INT_ARRAY GArray * g_array_free ax Array of int64 DBUS_TYPE_G_INT64_ARRAY GArray * g_array_free at Array of uint64 DBUS_TYPE_G_UINT64_ARRAY GArray * g_array_free ad Array of double DBUS_TYPE_G_DOUBLE_ARRAY GArray * g_array_free ab Array of boolean DBUS_TYPE_G_BOOLEAN_ARRAY GArray * g_array_free as Array of strings G_TYPE_STRV char ** g_strfreev 表三 字典(dict or hash)表 D-Bus type signature Description GType C typedef Free function a{ss} Dictionary mapping strings to strings DBUS_TYPE_G_STRING_STRING_HASHTABLE GHashTable * g_hash_table_destroy 示例源码 myglibdbus 编写session dbus服务端 xml的编写及绑定文件的生成 在GLib中，通过dbus表现出GObject，必须写XML文件描述这个对象的方法等属性。通过XML文件和dbus-binding-tool工具，可以很方便的自动创建出易于使用的dbus代理对象。例如下面的org.freedesktop.myglibdbus.xml文件描述了三个函数和一个信号，其中函数work有一个输入参数msg（char）和一个输出参数ret（gint），函数receive有一个输入参数msg（char）和一个输出参数ret（char*），函数exit有一个输出参数ret（gint），信号info_alert传递一个参数类型为字符串的变量。一个node可以有多个interface ,一个interface可以有多个method（函数）或signal（信号）。 org.freedesktop.myglibdbus.xml的具体内容如下： 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;node name=&quot;/org/freedesktop/myglibdbus&quot;&gt; &lt;interface name=&quot;org.freedesktop.myglibdbus&quot;&gt; &lt;method name=&quot;work&quot;&gt; &lt;annotation name=&quot;org.freedesktop.DBus.GLib.Async&quot; value=&quot;&quot; /&gt; &lt;arg type=&quot;s&quot; name=&quot;msg&quot; direction=&quot;in&quot;/&gt; &lt;arg type=&quot;i&quot; name=&quot;ret&quot; direction=&quot;out&quot; /&gt; &lt;/method&gt; &lt;method name=&quot;receive&quot;&gt; &lt;annotation name=&quot;org.freedesktop.DBus.GLib.Async&quot; value=&quot;&quot; /&gt; &lt;arg type=&quot;s&quot; name=&quot;msg&quot; direction=&quot;in&quot;/&gt; &lt;arg type=&quot;s&quot; name=&quot;ret&quot; direction=&quot;out&quot; /&gt; &lt;/method&gt; &lt;method name=&quot;exit&quot;&gt; &lt;annotation name=&quot;org.freedesktop.DBus.GLib.Async&quot; value=&quot;&quot; /&gt; &lt;arg type=&quot;i&quot; name=&quot;ret&quot; direction=&quot;out&quot; /&gt; &lt;/method&gt; &lt;signal name=&quot;info_alert&quot;&gt; &lt;arg type=&quot;s&quot; name=&quot;value&quot; direction=&quot;out&quot; /&gt; &lt;/signal&gt; &lt;/interface&gt;&lt;/node&gt; 在上面的XML中可以看到一行&lt;annotation name=&quot;org.freedesktop.DBus.GLib.Async&quot; value=&quot;&quot; /&gt;，其实，Annotations的方式有四种，分别如下：1234org.freedesktop.DBus.GLib.CSymbolorg.freedesktop.DBus.GLib.Asyncorg.freedesktop.DBus.GLib.Constorg.freedesktop.DBus.GLib.ReturnVal 通过dbus-binding-tool生成绑定文件 在进行代码编写之前，先确保系统安装了dbus相关的开发包，执行以下命令： $ sudo apt install libglib2.0-dev libdbus-glib-1-dev libdbus-1-dev 运行dbus-binding-tool工具（该工具来自包libdbus-glib-1-dev）,如下所示： 123$ dbus-binding-tool --mode=glib-server --prefix=myglibdbus org.freedesktop.myglibdbus.xml --output=myglibdbus-glue.h或者$ dbus-binding-tool --mode=glib-server --prefix=myglibdbus org.freedesktop.myglibdbus.xml &gt; myglibdbus-glue.h 执行上面的命令，则生成了绑定文件myglibdbus-glue.h，该文件无需修改，直接在本地代码中include使用即可。”–prefix”参数定义了对象前缀。设对象前缀是$(prefix)，则生成的DBusGObjectInfo结构变量名就是dbus_glib_$(prefix) _object_info，如：dbus_glib_myglibdbus_object_info。 绑定文件会为接口方法定义回调函数。回调函数的名称是这样的：首先将xml中的方法名称转换到全部小写，下划线分隔的格式，然后增加前缀$(prefix)_。例如xml中的函数work，绑定文件就会引用一个名称为$(prefix)_work的函数，即：myglibdbus_work。 创建对象 dbus-glib定义向dbus daemon申请一个注册信息的形式为GObject（C语言）的对象。dbus-glib用GObject实现dbus对象，故需要实现一个对象,继承于GObject。 新建文件myglidbus.h和myglibdbus.c，在头文件myglidbus.h中定义对象，如下所示： 1234567typedef struct _MyGlibDbus &#123; GObject parent;&#125; MyGlibDbus;typedef struct _MyGlibDbusClass &#123; GObjectClass parent_class;&#125; MyGlibDbusClass; 在GObject中，类是两个结构体的组合，一个是实例结构体，另一个是类结构体，MyGlibDbus是实例结构体，MyGlibDbusClass是类结构体。 实现类类型的定义 在myglibdbus.c文件中加入 G_DEFINE_TYPE(MyGlibDbus, myglibdbus, G_TYPE_OBJECT); G_DEFINE_TYPE可以让GObject库的数据类型系统能够识别我们所定义的MyGlibDbus类类型，它接受三个参数，第一个参数是类名，即MyGlibDbus；第二个参数则是类的成员函数（面向对象术语称之为“方法”或“行为”）名称的前缀，例如myglibdbus_get_type函数即为MyGlibDbus类的一个成员函数，“myglibdbus” 在myglibdbus.c文件中，需要include上面生成的绑定文件，即代码中加入：#include &quot;myglibdbus-glue.h&quot;，调用dbus_g_object_class_install_info进行类的初始化，传递对象和对象信息进去，如：dbus_g_object_type_install_info(MYGLIBDBUS_TYPE_OBJECET, &amp;dbus_glib_myglibdbus_object_info); 为了执行XML中的method，这里需要对每个method定义一个C函数，这里拿work函数进行说明，定义的C函数为：gint myglibdbus_work(MyGlibDbus *dbus, gchar *msg, DBusGMethodInvocation *ret_value, GError **error) 其中，第一个参数必须是对象实例的指针，跟在实例指针后面的参数 msg 是方法的输入参数，ret_value为输出参数，最后一个参数必须为GError **，如果函数返回失败，必须使用g_set_error填充该错误参数。 最后可以使用dbus_g_connection_register_g_object输出一个对象，如：dbus_g_connection_register_g_object(connection, MYGLIBDBUS_PATH, G_OBJECT(dbus)); 声明类的函数 123456789101112131415GType myglibdbus_get_type(void);//向GObject库所提供的类型管理系统提供要注册的MyGlibDbus类类型的相关信息,可以不实现，但必须要声明#define MYGLIBDBUS_TYPE_OBJECET (myglibdbus_get_type())//声明类的函数（类成员的构造函数）void myglibdbus_init(MyGlibDbus *dbus)&#123;&#125;//声明类的函数（类结构的构造函数，与类成员构造函数区别在于，该构造函数只在该类定义时运行一次，常用来进行消息信号的初始化等。而myglibdbus_init则在创建成员时都会调用一次（如obj = g_object_new））void myglibdbus_class_init(MyGlibDbusClass * kclass)&#123;&#125; 向dbus deamon申请注册 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849DBusGConnection * connection = NULL;DBusConnection *connect;DBusGProxy * dbus_proxy = NULL;GError * error = NULL;guint request_name_result;gint ret;dbus_g_thread_init();dbus = (MyGlibDbus*)myglibdbus_new();loop = g_main_loop_new(NULL, FALSE);connection = dbus_g_bus_get(DBUS_BUS_SESSION, &amp;error);if(connection == NULL)&#123; g_error(&quot;%s&quot;, error-&gt;message); goto out;&#125;//申请一个会话总线 DBUS_SERVICE_DBUS: org.freedesktop.DBus DBUS_PATH_DBUS: /org/freedesktop/DBus DBUS_INTERFACE_DBUS:org.freedesktop.DBusdbus_proxy = dbus_g_proxy_new_for_name(connection, DBUS_SERVICE_DBUS, DBUS_PATH_DBUS, DBUS_INTERFACE_DBUS);//调用dbusdaemon的函数“RequestName”，申请一个DBUS名为org.freedesktop.myglibdbus的注册信息ret = dbus_g_proxy_call(dbus_proxy, &quot;RequestName&quot;, &amp;error, G_TYPE_STRING, MYGLIBDBUS_NAME, G_TYPE_UINT, DBUS_NAME_FLAG_DO_NOT_QUEUE, G_TYPE_INVALID, G_TYPE_UINT, &amp;request_name_result, G_TYPE_INVALID);if(!ret)&#123; g_error(&quot;RequestName failed:%s&quot;, error-&gt;message); g_error_free(error); exit(EXIT_FAILURE);&#125;g_object_unref(G_OBJECT(dbus_proxy));//already runningif(request_name_result != DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER) exit(EXIT_FAILURE);dbus_g_object_type_install_info(MYGLIBDBUS_TYPE_OBJECET, &amp;dbus_glib_myglibdbus_object_info);//向dbus-glib登记对象信息//申请之前定义的一个对象MyGlibDbus，将该对象与bus绑定dbus_g_connection_register_g_object(connection, MYGLIBDBUS_PATH, G_OBJECT(dbus));g_main_loop_run(loop);//申请创建一个主循环out: g_main_loop_unref(loop); g_object_unref(dbus); 通过Dbus-glib编写客户端 使用dbus_g_proxy_call调用dbus服务的方法 12345678910111213141516GError *err = NULL;int ret = 0;if (!dbus_g_proxy_call(remote_object, &quot;work&quot;, &amp;err, G_TYPE_STRING, &quot;Hello world!&quot;, G_TYPE_INVALID, G_TYPE_INT, &amp;ret, G_TYPE_INVALID)) &#123;&#125;else &#123; if (err != NULL) &#123; if(err-&gt;domain == DBUS_GERROR &amp;&amp; err-&gt;code == DBUS_GERROR_REMOTE_EXCEPTION) printf(&quot;dbus send exception %s:%s&quot;,dbus_g_error_get_name(err), err-&gt;message); else printf(&quot;dbus send Error : %s\n&quot;, err-&gt;message); g_clear_error(&amp;err); &#125;&#125; 使用dbus-binding-tool –mode=glib-client方式调用dbus服务的方法 $ dbus-binding-tool --mode=glib-client --prefix=myglibdbus org.freedesktop.myglibdbus.xml &gt; myglibdbus_proxy.h 打开myglibdbus_proxy.h看到服务端提供的work方法已经转为： 123456static inline gbooleanorg_freedesktop_myglibdbus_work (DBusGProxy *proxy, const char * IN_msg, gint* OUT_ret, GError **error)&#123; return dbus_g_proxy_call (proxy, &quot;work&quot;, error, G_TYPE_STRING, IN_msg, G_TYPE_INVALID, G_TYPE_INT, OUT_ret, G_TYPE_INVALID);&#125; 客户端可以直接调用org_freedesktop_myglibdbus_work，而不再需要使用上面的dbus_g_proxy_call来调用work函数。 示例代码工程创建和编译演示 编写org.freedesktop.myglibdbus.xml文件 新建文件myglidbus.h、myglibdbus.c、server.c和client.c，并完成代码编写，其中myglidbus.h、myglibdbus.c、server.c三个文件是服务端代码文件，client.c是客户端代码文件。 执行autoscan，生成 configure.scan 和 autoscan.log，将configure.scan 修改为 configure.ac, 并修改configure.ac的内容。 $ autoscan configure.ac的初始内容如下： 1234567891011121314151617181920212223# -*- Autoconf -*-# Process this file with autoconf to produce a configure script.AC_PREREQ([2.69])AC_INIT([FULL-PACKAGE-NAME], [VERSION], [BUG-REPORT-ADDRESS])AC_CONFIG_SRCDIR([src/server.c])AC_CONFIG_HEADERS([config.h])# Checks for programs.AC_PROG_CC# Checks for libraries.# Checks for header files.AC_CHECK_HEADERS([stdlib.h string.h])# Checks for typedefs, structures, and compiler characteristics.# Checks for library functions.AC_CONFIG_FILES([Makefile src/Makefile])AC_OUTPUT 执行aclocal，生成aclocal.m4(处理本地宏文件)和 autom4te.cache $ aclocal 执行autoheader，生成生成config.h.in $ autoheader 执行autoconf，根据 configure.ac 和 aclocal.m4 生成 configure $ autoconf 编写 Makefile.am 和 src/Makefile.am 增加 NEWS、README、AUTHORS、ChangeLog 执行automake，生成 Makefile.in，src/Makefile.in, compile, COPYING, depcomp， INSTALL, install-sh 和 missing (根据 Makefile.am 和 aclocal.m4) $ automake --add-missing 执行configure，生成 Makefile, src/Makefile， config.log 和 config.status $ ./configure 执行make，生成二进制执行文件（src下server和client） $ make 未来可以改进的地方 多线程防冲突 上面示例代码只是单线程实现dbus调用。如果多线程的情况下，以及库函数情况下，为确保不同线程使用不同的DBusConnection，在创建dbus总线时要注意使用关键字创建各自私有的总线。 客户端实现 123456789101112GMainContext*main_context = NULL;main_context =g_main_context_new();//申请独立的context/* is dbus_g_bus_get_private， not dbus_g_bus_get dbus_g_bus_get_private申请的私有总线连接在使用完成后，要使用dbus_g_connection_close先关闭连接后再释放资源dbus_g_connection_unref, 否则只调用dbus_g_connection_unref会报“私有连接无法关闭”，导致内存泄露。*/bus = dbus_g_bus_get_private(DBUS_BUS_SESSION,main_context, &amp;error);…dbus_g_connection_close(bus);//私有的总线连接要先close才能unrefdbus_g_connection_unref(bus);g_main_context_unref(main_context);//g_main_context_unref()要与g_main_context_new() 配合使用，如果申请的资源未释放，会导致文件句柄泄露 消息接收端实现： 12345GMainContext*main_context = NULL;main_context= g_main_context_new();//申请独立的contextmainloop= g_main_loop_new (main_context, FALSE);g_main_loop_unref(mainloop);g_main_context_unref(main_context); 以这种方式实现的消息接收端，在多进程接收相同消息的情况下，只有一个进程能够接收到该消息，如果要多进程都能接收到消息，实现如下(使用系统默认的context与总线绑定)： 12main_context = g_main_context_default();mainloop = g_main_loop_new (main_context,FALSE); 或 1mainloop = g_main_loop_new (NULL, FALSE); dbus_g_connection_close的实现如下： 123456#define _DBUS_POINTER_UNSHIFT(p) ((void*) (((char*)p)- sizeof (void*)))#define DBUS_CONNECTION_FROM_G_CONNECTION(x) ((DBusConnection*)_DBUS_POINTER_UNSHIFT(x))void dbus_g_connection_close(DBusConnection * connection)&#123; returndbus_connection_close(DBUS_CONNECTION_FROM_G_CONNECTION(connection));&#125;]]></content>
      <categories>
        <category>Linux 编程</category>
      </categories>
      <tags>
        <tag>Dbus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用mpv编写自己的播放器]]></title>
    <url>%2F2019%2F08%2F19%2F2019-08-19-qt-mpv-player%2F</url>
    <content type="text"><![CDATA[MPV 是一个基于 MPlayer 和 MPlayer2 的多平台开源播放器，其在Linux上拥有广泛的输出设备支持，内置ffmpeg解码器，支持绝大部分的视频和音频格式，支持本地播放和网络播放，支持ass特效字幕，GPU 解码能力十分出色。虽然MPV功能强大，但默认情况下，MPV无GUI图形界面，用户需要通过命令行或者手动修改其配置文件达到配置MPV的目的，这样就给普通用户带来了诸多不便。为此，本文将介绍如何在Ubuntu系统上使用Qt编写带UI图形的MPV播放器，使用户对快速定制具有图形界面的MPV播放器有一个大致的了解。 示例源码 mympvplayer 开发前准备工作 Ubuntu上MPV的安装： 12$ sudo apt-get update$ sudo install mpv 编程开发依赖包安装： 1$ sudo install qtbase5-dev qt5-qmake qtscript5-dev qttools5-dev-tools 要点分析 为了实现一个既可以在Qt程序中控制MPV，又可以让Qt程序得到MPV的输出信息的播放器，这里重点介绍Qt的QProcess类。QProcess类可用来调用外部程序，并与外部程序进行通信。其把外部程序的进程当作一个有序的I/O设备，通过对通过I/O设备的读写来完成进程间的通信，即：write()函数实现对进程标准输入的写操作，通过read()，readLine()和getChar()函数实现对标准输出的读操作。在正常渠道模式下，QProcess的无名管道stdinChannelpipe，stdoutChannelpipe和stderrChannelpipe分别与标准输入、标准输出和标准容错进行绑定，实现与外部程序的通信；而在融合模式下，没有容错管道，此时，标准容错端和标准输出端将共同挂接到子进程的stdoutChannelpipe的写端来实现内外进程的通信，即标准输出和标准容错绑定到同一个管道的写端。本文介绍通过QProcess类调用MPV，并设置一系列播放参数，如视频驱动、音频驱动、软解/硬解、缓存等。至于Qt图形和MPV视频窗口的关联，则是使用“–wid widget-&gt;winId()”进行绑定，通过winId()可以获得一个数字，其中widget是一个QWidget对象，这样将界面上一个窗口的句柄给了MPV，即视频输出定位到了widget窗体部件中（wid为MPV指定了输入窗口，-wid参数只在X11、directX和OpenGL中适用）。本文推荐使用融合模式，代码为：setProcessChannelMode(QProcess::MergedChannels)。 配置介绍 查看MPV的帮助信息可在终端执行”mpv –help”， 查看MPV可配置信息可在终端执行”mpv –list-options”，查看快捷键列表可在终端执行”mpv —input-keylist”。MPV参数调用需要加”–”，如果参数是使用配置文件中的参数，则配置文件中无需在参数前加”–”。MPV的配置文件目录为：~/.config/mpv/，本文介绍的播放器定制将不使用配置文件，这里只简要介绍下mpv.conf和input.conf这两个配置文件的格式，mpv.conf 是主配置文件，里面包含一些基本的配置，input.conf 按键配置文件，包含播放过程中一些操作快捷键的设置。 mpv.conf 123456789# Disable the On Screen Controller (OSC).osc=no# Keep the player window on top of all other windows.ontop=yes# Enable hardware decoding if available. Often, this does not work with all# video outputs, but should work well with default settings on most systems.# If performance or energy usage is an issue, forcing the vdpau or vaapi VOs# may or may not help.hwdec=auto input.conf 123456789101112# Mouse wheels, touchpad or other input devices that have axes# if the input devices supports precise scrolling it will also scale the# numeric value accordinglyWHEEL_UP seek 10WHEEL_DOWN seek -10WHEEL_LEFT add volume -2WHEEL_RIGHT add volume 2## Seek units are in seconds, but note that these are limited by keyframesRIGHT seek 5LEFT seek -5UP seek 60DOWN seek -60 下面详细介绍几个比较重要的配置项 quiet 这个参数会阻止状态行信息的显示，即使得控制台消息尽量少输出。使用Qt嵌入MPV时，需要使用noquiet而不是quiet，否则Qt程序无法获得MPV的状态信息，致使Qt程序无法将MPV的状态准确的展示给用户，如播放进度、出错信息等。当然，如果你的机器性能差，那还是建议你直接使用mpv，且参数使用quiet，而不是像本文介绍的这样对MPV进行UI封装。MPV使用noquiet的格式为：mpv –no-quiet。 config 可让Qt程序将一些基本的配置通过从MPV命令获取各参数支持可选值，并设置一个默认值，且可通过图形展示给用户去选择。所以此处使用no-config，即不从MPV的配置文件读取参数。mpv使用no-config的格式为：mpv –no-config。 input-file 这里将不使用MPV的input.conf配置文件，而是通过标准输入stdin给MPV发送命令，命令后面带上换行”\n”写入stdin即可。另外，在直接使用MPV的过程中，–no-input-default-bindings将使得MPV无法响应按键的事件，而–input-default-bindings参数默认为yes，则可以让MPV响应按键事件。MPV使用input-file的格式为：mpv –input-file=/dev/stdin。 term-status-msg 该参数可以让MPV输出一些视频信息，可以通过 –term-status-msg 参数给它一个输出格式，如：”–term-status-msg=STATUS: ${=time-pos} / ${=duration:${=length:0}} P: ${=pause} B: ${=paused-for-cache} I: ${=core-idle} VB: ${=video-bitrate:0} AB: ${=audio-bitrate:0}” vo 通过命令“mpv –vo help”可查看MPV支持的视频驱动列表，Qt图形程序可以将列表展示出来供用户选择，并将选择的vo加入MPV的参数列表中，加入方式为：mpv –vo xxx，如：mpv –vo=xv。 ao 通过命令“mpv –ao help”可查看mpv支持的音频驱动列表，Qt图形程序可以将列表展示出来供用户选择，并将选择的ao加入mpv的参数列表中，加入方式为：mpv –ao xxx，如：mpv –ao=pulse。 hwdec hwdec为硬件解码配置，其可用配置列表和GPU有关，这里暂分析其中5种配置：no（软解），auto（自动尝试使用第一种可用的硬解方式），vdpau（用于vdpau和opengl的显示输出，即此时需要保证vo参数为gpu或者vdpau），vaapi（用于vaapi和opengl的视频输出，即此时需要保证vo参数为gpu或者vdapi，仅支持Intel GPU）和vaapi-copy（将视频拷贝回系统内存中，仅支持Intel GPU）。参数使用格式为：–hwdec=vaapi-copy。hwdec具体参数见文档：https://mpv.io/manual/stable/。 vd-lavc-threads 硬件解码线程数目，仅适用于MPEG-1/2和H.264，取值范围为0 - any，默认为0。使用格式如下：–vd-lavc-threads=4。 MPV支持的音/视频、字幕和播放列表格式的大部分列表 MPV支持的视频格式：avi 、vfw、divx、mpg、mpeg、m1v、m2v、mpv、dv、3gp、mov、mp4、m4v、mqv、dat、vcd、ogg、ogm、ogv、ogx、asf、wmv、bin、iso、vob、mkv、nsv、ram、flv、rm、swf、ts、rmvb、dvr-ms、m2t、m2ts、mts、rec、wtv、f4v、hdmov、webm、vp8、bik、smk、m4b、wtv、part MPV支持的音频格式：mp3、ogg、oga、wav、wma、aac、ac3、dts、ra、ape、flac、thd、mka、m4a、opus MPV支持的字幕格式：srt、sub、ssa、ass、idx、txt、smi、rt、utf、aqt、vtt MPV支持的列表格式：m3u、m3u8、pls、xspf Qt对MPV的控制 前面提及过Qt的QProcess类，这里描述下该类是如果设置MPV的参数和启动MPV的，即如何使用给标准输入控制MPV。MPV自动从标准输入中读取信息并执行，该类指令信息都需要以“\n”结尾。管道的读端描述符stdinChannelpipe[0]复制给了标准输入，即标准输入的描述符也为stdinChannelpipe[0]，隐藏按照标准输入的描述符去读信息就是到stdinChannelpipe所对应的管道中读取信息。QProcess的start()函数将开启进程，第一个参数即为mpv二进制，第二个参数为给mpv的参数列表，执行start()函数后，将完成内核中管道以及通信环境的建立。QProcess的成员函数write()向stdinChannelpipe[1]端写入信息，比如想让mpv退出，则通过write函数写入“quit \n”即可（write()函数将向stdinChannelpipe[1]端写入命令）。参考代码如下： 123456789QString mpvCmd = &quot;/usr/bin/mpv&quot;; QStringList args;args &lt;&lt; &quot;-- no-quiet&quot;;args &lt;&lt; &quot;--wid=100663330&quot;;args &lt;&lt; xxx.avi;process-&gt;start(mpvCmd, args);//启动播放waitForStarted();QString cmd = &quot;set pause yes&quot;;process-&gt;write(cmd.toLocal8Bit() + &quot;\n&quot;);//设置暂停 Qt获取MPV的信息 使用QProcess的融合模式，从标准输出和标准容错得到mpv 的信息。绑定QProcess的信号readyReadStandardOutput，当该信号出发时，再通过QProcess的readAllStandardOutput()函数获取信息（当然，这里也可以while循环来判断是否可以读取一行数据：while(process-&gt;canReadLine())，如果可以，则读取一行：QString line(process-&gt;readLine());），readAllStandardOutput获取的数据类型为QByteArray，对数据进行解析时通过“\n” 和“\r” 切分后一行一行解析，通过对每行的QByteArray数据进行详细解析可以得出MPV的状态信息，并将一些状态在Qt的图形程序上动态展示处理，比如MPV播放成功，则根据播放成功的信息将Qt图形的播放按钮设置为可暂停状态，此时点击该按钮给MPV发送的指令应该是暂停而非启动。另外，可以绑定QProcess的信号finished(int, QProcess::ExitStatus)，当该信号被触发时，通过判断QProcess的bytesAvailable()值，如果&gt;0，则通过QProcess的readAllStandardOutput()函数获取信息。 获取MPV的信息进行解析的难点是对繁杂冗余的信息进行过滤，针对关键字定位信息表示的意思。这里可以使用Qt的对获取的QRegExp来进行匹配。 下述正则表达式可用于分析出正在启动中： 12QRegExp rx_playing;rx_playing.setPattern(&quot;^Playing:.*|^\\[ytdl_hook\\].*&quot;); 下述正则表达式可可解析出暂停、缓存中等各种状态信息： 12QRegExp rx_av;rx_av.setPattern(&quot;^STATUS: ([0-9\\.-]+) / ([0-9\\.-]+) P: (yes|no) B: (yes|no) I: (yes|no) VB: ([0-9\\.-]+) AB: ([0-9\\.-]+)&quot;); 参考文档麒麟影音 mpv配置 mpv主页 mpv.conf input.conf]]></content>
      <categories>
        <category>Linux Qt 开发</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装Anbox]]></title>
    <url>%2F2019%2F08%2F14%2F2019-08-14-install-anbox%2F</url>
    <content type="text"><![CDATA[Anbox是一种基于容器在常规GNU/Linux系统上启动完整Android系統的方法，如Ubuntu。Anbox 使用 Linux 命名空间机制（user，pid，uts，net，mount，ipc），在容器中运行完整的 Android 系统，容器内的 Android 没有直接访问任何硬件的权限，所有的硬件访问通过主机上的 anbox 守护进程。Anbox复用基于 QEMU 的模拟器中为 Android 所做的 OpenGL ES 加速渲染的实现。容器内的 Android 系统使用不同的管道与主机系统通信，并通过它们发送所有的硬件访问命令。 使用apt和snap安装Anbox 安装内核模块 anbox-modules-dkms包含ashmem和binder内核模块，安装anbox-modules-dkms后，必须手动加载内核模块。下次系统启动时，它们将自动加载。 12345678$ sudo add-apt-repository ppa:morphis/anbox-support$ sudo apt update$ sudo apt install linux-headers-generic anbox-modules-dkms$ sudo modprobe ashmem_linux$ sudo modprobe binder_linux$ ls -1 /dev/&#123;ashmem,binder&#125;/dev/ashmem/dev/binder 安装和更新Anbox snap 123$ sudo apt install snapd$ sudo snap install --devmode --beta anbox$ snap refresh --beta --devmode anbox 查看当前可用的Anbox信息 $ snap info anbox 启动Anbox $ anbox.appmgr Anbox启动后，应用管理器界面如下所示： 点击应用管理器中的Settings的图标，启动Settings，界面如下所示： 安装安卓应用 1234$ sudo apt install android-tools-adb$ adb install qq.apk37616 KB/s (71677112 bytes in 1.860s)Failure [INSTALL_FAILED_NO_MATCHING_ABIS: Failed to extract native libraries, res=-113] 上面执行adb install qq.apk报错了，原因是当前机器为x86结构，如果是在arm64上，则不会出现该问题。如果想在x86下安装apk，需要找x86的包，可以从apk mirror下载，当然，这里的包根本无法满足我的需要，很可能也满足不了你的需要。那么，问题来了，想在x86下使用应用商店的那些apk（arm版本），有没有什么办法呢？ 办法总比困难多，这里可以使用 libhoudini。当然，在集成 libhoudini 来支持 ARM 后，也并非所有 Android 应用和游戏都能在 Anbox 中运行。某些 Android 应用和游戏可能根本不会出现在 Google Play 商店中，而一些应用和游戏可能可以安装但无法使用。此外，某些应用可能无法使用某些功能。默认情况下，Anbox 没有 Google Play 商店或 ARM 应用支持。要安装应用，必须下载每个应用的 APK 并使用 adb 手动安装。如上面提及的安装报错，默认情况下不能使用 Anbox 安装 ARM 应用或游戏，可以在 Anbox 中手动设置 Google Play 商店和 ARM 应用支持（使用 libhoudini），但该过程较复杂。为了更容易地在 Anbox 上安装 Google Play 商店和 Google Play 服务，并让它支持 ARM 应用程序和游戏（使用 libhoudini）， geeks-r-us.de上有人创建了一个自动执行这些任务的脚本。 安装 Google Play 商店并在 Anbox 上启用 ARM 应用/游戏支持 1、 安装所需的依赖项（wget、lzip、unzip 和 squashfs-tools） sudo apt install wget lzip unzip squashfs-tools dnsmasq 2、 下载并运行脚本，在 Anbox 上自动下载并安装 Google Play 商店（和 Google Play 服务）和 libhoudini（用于 ARM 应用/游戏支持），也可以直接从我的git上下载该脚本install-playstore.sh 123wget https://raw.githubusercontent.com/geeks-r-us/anbox-playstore-installer/master/install-playstore.shchmod +x install-playstore.shsudo ./install-playstore.sh 3、要让 Google Play 商店在 Anbox 中运行，你需要启用 Google Play 商店和 Google Play 服务的所有权限，运行Anbox $ anbox.appmgr 然后进入“设置 &gt; 应用 &gt; Google Play 服务 &gt; 权限”并启用所有可用权限。对 Google Play 商店也一样。至此，应该可以使用 Google 帐户登录 Google Play 商店了。 如果未启用 Google Play 商店和 Google Play 服务的所有权限，你可能会在尝试登录 Google 帐户时可能会遇到问题，并显示以下错误消息：“Couldn’t sign in. There was a problem communicating with Google servers. Try again later“，如你在下面的截图中看到的那样： 登录后，你可以停用部分 Google Play 商店/Google Play 服务权限。如果在 Anbox 上登录 Google 帐户时遇到一些连接问题，请确保 anbox-bride.sh 正在运行： 启动：$ sudo /snap/anbox/current/bin/anbox-bridge.sh start 重启：$ sudo /snap/anbox/current/bin/anbox-bridge.sh restart 卸载Anbox 123$ snap remove anbox$ sudo apt install ppa-purge$ sudo ppa-purge ppa:morphis/anbox-support 参考文档Anbox主页 Anbox代码托管 Android 硬件 OpenGL ES 模拟设计概述 Android QEMU fast pipes The Android “qemud” multiplexing daemon Android qemud services]]></content>
      <categories>
        <category>安卓开发</category>
      </categories>
      <tags>
        <tag>Android Anbox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Binder]]></title>
    <url>%2F2018%2F08%2F11%2F2018-08-11-android-binder%2F</url>
    <content type="text"><![CDATA[在Binder库中，Service组件和Client组件分别使用模板类BnInterface和BpInterface来描述，前者称为Binder本地对象，后者称为Binder代理对象。Binder库中的Binder本地对象和Binder代理对象分别对应于Binder驱动程序中的Binder实体对象和Binder引用对象。下面将简要介绍Binder进程间的通信，代码包含Server进程和Client进程，Server进程实现了一个Service组件，负责管理前面介绍的虚拟硬件设备mydev的寄存器val，并且向Client进程提供访问服务。以下将实例划分为common、server和client三个模块，其中common实现了硬件访问服务接口IMydevService，以及Binder本地对象类BnMydevService和Binder代理对象类BpMydevService；server实现了一个Server进程，里面包含一个Service组件MydevService；client实现了一个Client进程，它通过一个BpMydevService代理对象去访问运行在Server进程中的Service组件MydevService所提供的服务。 程序目录结构12345678910~/Android/external/binder----common ----IMydevgService.h ----IMydevService.cpp----server ----MydevServer.cpp ----Android.mk----client ----MydevClient.cpp ----Android.mk Server进程 common/IMydevService.h 123456789101112131415161718192021222324252627#ifndef IMYDEVSERVICE_H_#define IMYDEVSERVICE_H_#include &lt;utils/RefBase.h&gt;#include &lt;binder/IInterface.h&gt;#include &lt;binder/Parcel.h&gt;#define MYDEV_SERVICE "com.eightplus.MydevService" //MYDEV_SERVICE用来描述Service组件MydevService注册到Service Manager的名称using namespace android;//硬件访问服务接口class IMydevService: public IInterface&#123;public: DECLARE_META_INTERFACE(MydevService); virtual int32_t getVal() = 0;//读取虚拟硬件设备mydev中寄存器val的值 virtual void setVal(int32_t val) = 0;//向虚拟硬件设备mydev中寄存器val中写入值&#125;;//Binder本地对象类BnMydevServiceclass BnMydevService: public BnInterface&lt;IMydevService&gt;&#123;public: virtual status_t onTransact(uint32_t code, const Parcel &amp;data, Parcel *reply, uint32_t flags= 0);&#125;;#endif common/IMydevService.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#define LOG_TAG "IMydevService"#include &lt;utils/Log.h&gt;#include "IMydevService.h"using namespace android;enum&#123; GET_VAL = IBinder::First_CALL_TRANSACTION; SET_VAL = IBinder::First_CALL_TRANSACTION + 1;&#125;;class BpMydevService: public BpInterface&lt;IMydevService&gt;&#123;public: BpMydevService(const sp&lt;IBinder&gt;&amp; impl): BpInterface&lt;IMydevService&gt;(impl) &#123; &#125;public: int32_t getVal() &#123; Parcel data; data.writeInterfaceToken(IMydevService::getInterfaceDescriptor()); Parcel reply; remote()-&gt;transact(GET_VAL, data, &amp;reply); int32_t val = reply.readInt32(); return val; &#125; void setVal(int32_t val) &#123; Parcel data; data.writeInterfaceToken(IMydevService::getInterfaceDescriptor()); data.writeInt32(val); Parcel reply; remote-&gt;transact(SET_VAL, data, &amp;reply); &#125;&#125;;IMPLEMENT_META_INTERFACE(MydevService, "com.eightplus.IMydevService");status_t BnMydevService::onTransact(uint32_t code, const Parcel &amp;data, Parcel *reply, uint32_t flags)&#123; switch(code) &#123; case GET_VAL: &#123; CHECK_INTERFACE(IMydevService, data, reply); int32_t val = getVal(); reply-&gt;writeInt32(val); return NO_ERROR; &#125; case SET_VAL: &#123; CHECK_INTERFACE(IMydevService, data, reply); int32_t val = data.readInt32(); setVal(val); return NO_ERROR; &#125; default: &#123; return BBinder::onTransact(code, data, reply, flags); &#125; &#125;&#125; server/MydevServer.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#define LOG_TAG "MydevServer"#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;utils/Log.h&gt;#include &lt;binder/IServiceManager.h&gt;#include &lt;binder/IPCThreadState.h&gt;#include "../common/IMydevService.h"#define MYDEV_DEVICE_NAME "/dev/mydev"//Service组件类MydevServiceclass MydevService: public BnMydevService&#123;public: MydevService() &#123; fd = open(MYDEV_DEVICE_NAME, O_RDWR); if(fd == -1) LOGE("Failed to open device %s.\n", MYDEV_DEVICE_NAME); &#125; virtual ~MydevService() &#123; if(fd != -1) close(fd); &#125;public: static void instantiate() &#123; defaultServiceManager()-&gt;addService(String16(MYDEV_SERVICE), new MydevService()); &#125; int32_t getVal() &#123; int32_t val = 0; if(fd != -1) read(fd, &amp;val, sizeof(val)); rerurn val; &#125; void setVal(int32_t val) &#123; if(fd != -1) write(fd, &amp;val, sizeof(val)); &#125;private: int fd;&#125;;int main(int argc, char** argv)&#123; MydevService::instantiate();//将MydevService组件注册到Service Manager中 ProcessState::self()-&gt;startThreadPool();//启动一个Binder线程池 IPCThreadState::self()-&gt;joinThreadPool();//将主线程添加到进程的Binder线程池中，用来处理来自Client进程的通信请求 return 0;&#125; server/Android.mk12345678LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE_TAGS := optionalLOCAL_SRC_FILES := ../common/IMydevService.cpp \ MydevServer.cppLOCAL_SHARED_LIBRARIES := libcutils libutils libbinderLOCAL_PACKAGE_NAME := MydevServerinclude $(BUILD_EXECUTABLE) Client进程 client/MydevClient.cpp 1234567891011121314151617181920212223242526272829303132333435#define LOG_TAG "MydevClient"#include &lt;utils/Log.h&gt;#include &lt;binder/IServiceManager.h&gt;#include "../common/IMydevService.h"int main()&#123; sp&lt;IBinder&gt; binder = defaultServiceManager()-&gt;getService(String16(MYDEV_SERVICE)); if (binder == NULL) &#123; LOGE("Failed to get mydev service: %s.\n", MYDEV_SERVICE); return -1; &#125; sp&lt;IMydevService&gt; service = IMydevService::asInterface(binder); if (service == NULL) &#123; LOGE("Failed to get mydev service interface.\n"); return -2; &#125; printf("Read original value from MydevService:\n"); int32_t val = service-&gt;getVal(); printf(" %d.\n", val);//0 printf("Add value 1 to MydevService.\n"); val += 1; service-&gt;setVal(val); printf("Read the value from MydevService again:\n"); val = service-&gt;getVal(); printf(" %d.\n", val);//1 return 0;&#125; client/Android.mk12345678LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE_TAGS := optionalLOCAL_SRC_FILES := ../common/IMydevService.cpp \ MydevClient.cppLOCAL_SHARED_LIBRARIES := libcutils libutils libbinderLOCAL_PACKAGE_NAME := MydevClientinclude $(BUILD_EXECUTABLE) 单独编译server和client ~/Android$ mmm ./external/binder/server/ ~/Android$ mmm ./external/binder/client/ 编译完成之后，就可以在out/target/product/generic/system/bin目录下看到编译结果的输出文件MydevServer和MydevClient了 重新打包system.img文件 ~/Android$make snod 运行模拟器： ~/Android$emulator -kernel kernel/goldfish/arch/arm/boot/zImage &amp; ~/Android$ adb shell root@android:/ # cd system/bin root@android:/system/bin # ./MydevServer &amp; root@android:/system/bin # ./MydevXClient12345Read original value from MydevService:0.Add value 1 to MydevService.Read the value from MydevService again:1.]]></content>
      <categories>
        <category>安卓开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Android源码中使用java编写自己的应用程序]]></title>
    <url>%2F2018%2F08%2F09%2F2018-08-09-android-java-app%2F</url>
    <content type="text"><![CDATA[HelloWorld 程序目录结构如下： 12345678910111213~/Android/packages/experimental/HelloWorld----AndroidMainifest.xml----Android.mk----src ----com/eightplus/mydev ----HelloWorld.java----res ----layout ----main.xml ----values ----strings.xml ----drawable ----icon.png HelloWorld.java 12345678910111213141516package com.eightplus.helloimport android.app.Activity;import android.os.Bundle;import android.util.log;public class HelloWorld extends Activity &#123; private final static String LOG_TAG = "HelloWorld"; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); Log.i(LOG_TAG, "HelloWorld, Welcome!!!"); &#125;&#125; main.xml 12345678910111213&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="fill_parent" android:layout_height="fill_parent" android:gravity="center"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:gravity="center" android:text="@string/hello_world" &gt; &lt;/TextView&gt;&lt;/LinearLayout&gt; strings.xml 12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;string name="app_name"&gt;HellWorld&lt;/string&gt; &lt;string name="hello_world"&gt;Hello World&lt;/string&gt;&lt;/resources&gt; icon.png是应用程序的图标 AndroidMainifest.xml 12345678910111213141516&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;mainifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.eightplus.hello" android:versionCode="1" android:versionName="1.0"&gt; &lt;application android:icon="@drawable/icon" android:label="@string/app_name"&gt; &lt;activity android:name=".HelloWorld" android:label="@string/app_name"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/mainifest&gt; Android.mk 123456LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE_TAGS := optionalLOCAL_SRC_FILES := $(call all-subdir-java-files)LOCAL_PACKAGE_NAME := HelloWorldinclude $(BUILD_PACKAGE) 使用mmm命令单独编译HelloWorkd程序 ~/Android$ mmm ./packages/experimental/HelloWorld/编译完成之后，就可以在out/target/product/generic/system/app目录下看到编译结果的输出文件HelloWorld.apk了。 重新打包Android系统文件system.img ~/Android$ make snod 运行模拟器 ~/Android$ emulator Activity组件应用实例该实例由三个Acitity组件组成：MainActivity、SubActivityInProcess和SubActivityInNewProcess。MainActivity是根Acitity，SubActivityInProcess和SubActivityInNewProcess是子Acitity。MainActivity和SubActivityInProcess运行在同一个进程中，而SubActivityInNewProcess运行在一个独立的进程中。 程序目录结构如下： 12345678910111213141516~/Android/packages/experimental/Activity----AndroidMainifest.xml----Android.mk----src ----com/eightplus/activity ----MainActivity.java ----SubActivityInProcess.java ----SubActivityInNewProcess.java----res ----layout ----main.xml ----sub.xml ----values ----strings.xml ----drawable ----icon.png MainActivity.java SubActivityInProcess和SubActivityInNewProcess的组件名字分别被配置为”com.eightplus.activity.subactivity.in.process”和”com.eightplus.activity.subactivity.in.new.process”，因此调用成员和函数startActivity启动它们时，只需要分别指定这两个名称即可，不需要知道它们是哪个类来实现的。1234567891011121314151617181920212223242526272829303132333435363738394041package com.eightplus.activity; import android.app.Activity; import android.content.Intent; import android.os.Bundle; import android.util.Log; import android.view.View; import android.view.View.OnClickListener; import android.widget.Button; public class MainActivity extends Activity implements OnClickListener &#123; private final static String LOG_TAG = "com.eightplus.activity.MainActivity"; private Button startInProcessButton = null; private Button startInNewProcessButton = null; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); startInProcessButton = (Button)findViewById(R.id.button_start_in_process); startInNewProcessButton = (Button)findViewById(R.id.button_start_in_new_process); startInProcessButton.setOnClickListener(this); startInNewProcessButton.setOnClickListener(this); Log.i(LOG_TAG, "Main Activity Created."); &#125; @Override public void onClick(View v) &#123; if(v.equals(startInProcessButton)) &#123; Intent intent = new Intent("com.eightplus.activity.subactivity.in.process"); startActivity(intent); &#125; else if(v.equals(startInNewProcessButton)) &#123; Intent intent = new Intent("com.eightplus.activity.subactivity.in.new.process"); startActivity(intent); &#125; &#125; &#125; SubActivityInProcess.java 1234567891011121314151617181920212223242526272829303132package com.eightplus.activity; import android.app.Activity; import android.os.Bundle; import android.util.Log; import android.view.View; import android.view.View.OnClickListener; import android.widget.Button; public class SubActivityInProcess extends Activity implements OnClickListener &#123; private final static String LOG_TAG = "com.eightplus.activity.SubActivityInProcess"; private Button finishButton = null; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.sub); finishButton = (Button)findViewById(R.id.button_finish); finishButton.setOnClickListener(this); Log.i(LOG_TAG, "Sub Activity In Process Created."); &#125; @Override public void onClick(View v) &#123; if(v.equals(finishButton)) &#123; finish(); &#125; &#125; &#125; SubActivityInNewProcess.java 1234567891011121314151617181920212223242526272829303132package com.eightplus.activity; import android.app.Activity; import android.os.Bundle; import android.util.Log; import android.view.View; import android.view.View.OnClickListener; import android.widget.Button; public class SubActivityInNewProcess extends Activity implements OnClickListener &#123; private final static String LOG_TAG = "com.eightplus.activity.SubActivityInNewProcess"; private Button finishButton = null; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.sub); finishButton = (Button)findViewById(R.id.button_finish); finishButton.setOnClickListener(this); Log.i(LOG_TAG, "Sub Activity In New Process Created."); &#125; @Override public void onClick(View v) &#123; if(v.equals(finishButton)) &#123; finish(); &#125; &#125; &#125; main.xml 123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="fill_parent" android:layout_height="fill_parent" android:gravity="center"&gt; &lt;Button android:id="@+id/button_start_in_process" android:layout_width="wrap_content" android:layout_height="wrap_content" android:gravity="center" android:text="@string/start_in_process" &gt; &lt;/Button&gt; &lt;Button android:id="@+id/button_start_in_new_process" android:layout_width="wrap_content" android:layout_height="wrap_content" android:gravity="center" android:text="@string/start_in_new_process" &gt; &lt;/Button&gt;&lt;/LinearLayout&gt; sub.xml 1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="fill_parent" android:layout_height="fill_parent" android:gravity="center"&gt; &lt;Button android:id="@+id/button_finish" android:layout_width="wrap_content" android:layout_height="wrap_content" android:gravity="center" android:text="@string/finish" &gt; &lt;/Button&gt;&lt;/LinearLayout&gt; strings.xml 12345678&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;string name="app_name"&gt;Activity&lt;/string&gt; &lt;string name="sub_activity"&gt;Sub Activity&lt;/string&gt; &lt;string name="start_in_process"&gt;Start sub-activity in process&lt;/string&gt; &lt;string name="start_in_new_process"&gt;Start sub-activity in new process&lt;/string&gt; &lt;string name="finish"&gt;Finish activity&lt;/string&gt;&lt;/resources&gt; icon.png为应用程序的图标 AndroidMainifest.xml 1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.eightplus.activity" android:versionCode="1" android:versionName="1.0"&gt; &lt;application android:icon="@drawable/icon" android:label="@string/app_name"&gt; &lt;activity android:name=".MainActivity" android:label="@string/app_name" android:process="com.eightplus.activity.mainprocess"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:label="@string/sub_activity" android:name=".SubActivityInProcess" android:process="com.eightplus.activity.mainprocess"&gt; &lt;intent-filter&gt; &lt;action android:name="com.eightplus.activity.subactivity.in.process"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:label="@string/sub_activity" android:name=".SubActivityInNewProcess" android:process="com.eightplus.activity.newprocess"&gt; &lt;intent-filter&gt; &lt;action android:name="com.eightplus.activity.subactivity.in.new.process"/&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; Android.mk 123456LOCAL_PATH:= $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE_TAGS := optionalLOCAL_SRC_FILES := $(call all-subdir-java-files)LOCAL_PACKAGE_NAME := Activityinclude $(BUILD_PACKAGE) 编译和打包 ~/Android$ mmm packages/experimental/Activity ~/Android$ make snod 启动模拟器 ~/Android$ emulator Service组件应用实例该实例由一个Service组件CounterService和一个Activity组件Counter组成。CounterService组件实现了一个计数器服务，它是由Counter组件启动起来的，并且与Counter组件绑定在一起。CounterService组件在内部使用一个异步任务(AsyncTask)来实现一个计数器，每隔一秒就将内部的计数加1,并且实时地将这个计数显示在Counter组件的用户界面上。由于计数器需要不停地执行加数功能，所以这里将它放在一个后台程序中运行，避免Counter组件不能及时地响应用户界面事件。 程序目录结构如下： 1234567891011121314151617~/Android/packages/experimental/Counter----AndroidMainifest.xml----Android.mk----src ----com/eightplus/counter ----ICounterCallback.java ----ICounterService.java ----CounterService.java ----Counter.java----res ----layout ----main.xml ----sub.xml ----values ----strings.xml ----drawable ----icon.png ICounterCallback.java 12345package com.eightplus.counterpublicd interface ICounterCallback &#123; void count(int val);&#125; ICounterService.java 123456package com.eightplus.counterpublicd interface ICounterService &#123; public void startCounter(int initVal, ICounterCallback callback); public void stopCounter();&#125; CounterService.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.eightplus.counterimport android.app.Service;import android.content.Intent;import android.os.AsyncTask;import android.os.Binder;import android.os.IBinder;import android.util.Log;public class CounterService extends Service implements ICounterService &#123; private final static String LOG_TAG = "com.eightplus.activity.CounterService"; private bool stop = false; private ICounterCallback counterCallback = null; private final IBinder binder = new CounterBinder(); public class CounterBinder extends Binder &#123; public CounterService getService() &#123; return CounterService.this; &#125; &#125; @Override public IBinder onBind(Intent intent) &#123; return binder; &#125; @Override public void onCreate() &#123; super.onCreate(); Log.i(LOG_TAG, "Counter Service Created."); &#125; public void startCounter(int initVal, ICounterCallback callback) &#123; counterCallback = callback; AsyncTask&lt;Integer, Integer, Integer&gt; task = new AsyncTask&lt;Integer, Integer, Integer&gt;() &#123; @Override protected Integer doInBackground(Integer... vals) &#123; Integer initCounter = vals[0]; stop = false; while(!stop) &#123; publishProcess(initCounter); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; initCounter++; &#125; return initCounter; &#125; @Override protected void onProgressUpdate(Integer... values) &#123; super.onProgressUpdate(values); int val = values[0]; counterCallback.count(val); &#125; @Override protected void onPostExecute(Integer val) &#123; counterCallback.count(val); &#125; &#125;; task.execute(initVal); &#125; public void stopCounter() &#123; stop = true; &#125;&#125; Counter.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.eightplus.counterimport android.app.Activity;import android.content.ComponentName;import android.content.Context;import android.content.Intent;import android.content.IntentFilter;import android.content.ServiceConnection;import android.os.Bundle;import android.os.IBinder;import android.util.Log;import android.view.View;import android.view.onClickListener;import android.widget.Button;import android.widget.TextView;public class Counter extends Activity implements OnClickListener, ICounterCallback &#123; private final static String LOG_TAG = "com.eightplus.activity.Counter"; private Button startButton = null; private Button stopButton = null; private TextView counterText = null; private ICounterService counterService = null; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); startButton = (Button)findViewById(R.id.button_start); stopButton = (Button)findViewById(R.id.button_stop); counterText = (TextView)findViewById(R.id.textview_counter); startButton.setOnClickListener(this); stopButton.setOnClickListener(this); startButton.setEnabled(true); stopButton.setEnabled(false); Intent bindIntent = new Intent(Counter.this, CounterService.class); bindService(bindIntent, serviceConnection, Context.BIND_AUTO_CREATE); Log.i(LOG_TAG, "Counter Activity Created."); &#125; @Override public void onDestroy() &#123; super.onDestory(); unbindService(serviceConnection); &#125; @Override public void onClick(View v) &#123; if(v.equals(startButton)) &#123; if (counterService != null) &#123; counterService.startCounter(0, this); startButton.setEnabled(false); stopButton.setEnabled(true); &#125; &#125; else if(v.equals(stopButton)) &#123; if (counterService != null) &#123; counterService.stopCounter(); startButton.setEnabled(true); stopButton.setEnabled(false); &#125; &#125; &#125; @Override public void count(int val) &#123; String text = String.valueOf(val); counterText.setText(text); &#125; private ServiceConnection serviceConnection = new ServiceConnection() &#123; public void onServiceConnected(ComponentName className, IBinder service) &#123; counterService = ((CounterService.CounterBinder)service).getService(); Log.i(LOG_TAG, "Counter Service Connected"); &#125; public void onServiceDisconnected(ComponentName className) &#123; counterService = null; Log.i(LOG_TAG, "Counter Service DisConnected"); &#125;&#125; main.xml 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="fill_parent" android:layout_height="fill_parent" android:gravity="center"&gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="wrap_content" android:layout_marginBottom="10px" android:orientation="horizontal" android:gravity="center"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginBottom="4px" android:gravity="center" android:text="@string/counter"&gt; &lt;/TextView&gt; &lt;TextView android:id="@+id/textview_counter" android:layout_width="wrap_content" android:layout_height="wrap_content" android:gravity="center" android:text="@string/init_counter"&gt; &lt;/TextView&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width="fill_parent" android:layout_height="wrap_content" android:orientation="horizontal" android:gravity="center"&gt; &lt;Button android:id="@+id/button_start" android:layout_width="wrap_content" android:layout_height="wrap_content" android:gravity="center" android:text="@string/start"&gt; &lt;/Button&gt; &lt;Button android:id="@+id/button_stop" android:layout_width="wrap_content" android:layout_height="wrap_content" android:gravity="center" android:text="@string/stop"&gt; &lt;/Button&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; strings.xml 12345678&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;string name="app_name"&gt;Counter&lt;/string&gt; &lt;string name="counter"&gt;Counter:&lt;/string&gt; &lt;string name="init_counter"&gt;0&lt;/string&gt; &lt;string name="start"&gt;Start Counter&lt;/string&gt; &lt;string name="stop"&gt;Stop Counter&lt;/string&gt;&lt;/resources&gt; icon.png为应用程序的图标 AndroidMainifest.xml 123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.eightplus.counter" android:versionCode="1" android:versionName="1.0"&gt; &lt;application android:icon="@drawable/icon" android:label="@string/app_name"&gt; &lt;activity android:name=".Counter" android:label="@string/app_name" &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;service android:name=".CounterService" android:enabled="true"&gt; &lt;/service&gt; &lt;/application&gt;&lt;/manifest&gt; Android.mk 123456LOCAL_PATH:= $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE_TAGS := optionalLOCAL_SRC_FILES := $(call all-subdir-java-files)LOCAL_PACKAGE_NAME := Counterinclude $(BUILD_PACKAGE) 编译和打包 ~/Android$ mmm ./packages/experimental/Counter/ ~/Android$ make snod 启动模拟器 ~/Android$ emulator]]></content>
      <categories>
        <category>安卓开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Android源码中编写C程序测试Linux内核驱动程序]]></title>
    <url>%2F2018%2F08%2F06%2F2018-08-06-test-android-kernel-driver-program%2F</url>
    <content type="text"><![CDATA[在mydev的Linux内核驱动程序中，创建三个不同的文件节点来供用户空间访问，分别是传统的设备文件/dev/mydev、proc系统文件/proc/mydev和devfs系统属性文件/sys/class/mydev/mydev/val。这里通过编写的C可执行程序来访问设备文件/dev/mydev。 驱动程序目录结构如下： 12345~/Android----external ----mydev ----mydev.c ----Android.mk 使用Android模拟器加载包含这个Linux驱动程序的内核文件，并且使用adb shell命令连接上模拟，验证在/dev目录中存在设备文件mydev。 进入到Android源代码工程的external目录，创建mydev目录 ~/Android$ cd external ~/Android/external$ mkdir mydev 在mydev目录中新建mydev.c文件 打开/dev/mydev文件，然后先读出/dev/mydev文件中的值，接着写入值5到/dev/mydev中去，最后再次读出/dev/mydev文件中的值，看看是否是我们刚才写入的值5。从/dev/mydev文件读写的值实际上就是我们虚拟的硬件的寄存器val的值。 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#define DEVICE_NAME "/dev/mydev"int main(int argc, char** argv)&#123; int fd = -1; int val = 0; fd = open(DEVICE_NAME, O_RDWR); if(fd == -1) &#123; printf("Failed to open device %s.\n", DEVICE_NAME); return -1; &#125; printf("Read original value:\n"); read(fd, &amp;val, sizeof(val)); printf("%d.\n\n", val); val = 5; printf("Write value %d to %s.\n\n", val, DEVICE_NAME); write(fd, &amp;val, sizeof(val)); printf("Read the value again:\n"); read(fd, &amp;val, sizeof(val)); printf("%d.\n\n", val); close(fd); return 0;&#125; 在mydev目录中新建Android.mk文件，其中“BUILD_EXECUTABLE”表示编译的是可执行程序 123456LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE_TAGS := optionalLOCAL_MODULE := mydevLOCAL_SRC_FILES := $(call all-subdir-c-files)include $(BUILD_EXECUTABLE) 使用mmm命令进行编译 ~/Android$ mmm ./external/mydev若编译成功，则可以在out/target/product/gerneric/system/bin目录下看到可执行文件mydev。 重新打包Android系统文件system.img，重新打包后的system.img文件包含了刚才编译好的mydev可执行文件。 ~/Android$ make snod 运行模拟器，使用/system/bin/mydev可执行程序来访问Linux内核驱动程序 ~/Android$ emulator -kernel ./kernel/goldfish/arch/arm/boot/zImage &amp; ~/Android$ adb shell root@android:/ # cd system/bin root@android:/system/bin # ./mydev12345Read the original value:0.Write value 5 to /dev/mydev.Read the value again:5.]]></content>
      <categories>
        <category>安卓开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为Android系统编写Linux内核驱动程序]]></title>
    <url>%2F2018%2F08%2F02%2F2018-08-02-android-kernel-driver%2F</url>
    <content type="text"><![CDATA[这里使用一个虚拟的硬件设备，这个设备只有一个4字节的寄存器，它可读可写。这里把这个虚拟的设备命名为“mydev”，而这个内核驱动程序也命名为mydev驱动程序。这里通过cat命令直接访问/proc/mydev和/sys/class/mydev/mydev/val文件验证驱动程序的正确性。 驱动程序目录结构如下： 1234567~/Android/kernel/goldfish----drivers ----mydev ----mydev.h ----mydev.c ----Kconfig ----Makefile 新建mydev目录 ~/Android$ cd kernel/goldfish/drivers ~/Android/kernel/goldfish/drivers$ mkdir mydev 在mydev目录中增加mydev.h文件 123456789101112131415161718#ifndef _MYDEV_ANDROID_H_#define _MYDEV_ANDROID_Hpp#include &lt;linux/cdev.h&gt;#include &lt;linux/semaphore.h&gt;#define MYDEV_DEVICE_NODE_NAME "helmydevlo"#define MYDEV_DEVICE_FILE_NAME "mydev"#define MYDEV_DEVICE_PROC_NAME "mydev"#define MYDEV_DEVICE_CLASS_NAME "mydev"//字符设备结构体struct mydev_android_dev &#123; int val;//寄存器 struct semaphore sem;//信号量 struct cdev dev;//内嵌的字符设备&#125;;#endif 在mydev目录中增加mydev.c文件，这是驱动程序的实现部分。驱动程序的功能主要是向上层提供访问设备的寄存器的值，包括读和写。这里，提供了三种访问设备寄存器的方法，一是通过proc文件系统来访问，二是通过传统的设备文件的方法来访问，三是通过devfs文件系统来访问。下面分段描述该驱动程序的实现。 首先是包含必要的头文件和定义三种访问设备的方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/types.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/proc_fs.h&gt;#include &lt;linux/device.h&gt;#include &lt;asm/uaccess.h&gt;#include "mydev.h"/*主设备和从设备号变量*/static int mydev_major = 0;static int mydev_minor = 0;/*设备类别和设备变量*/static struct class* mydev_class = NULL;static struct mydev_android_dev* mydev_dev = NULL;/*传统的设备文件操作方法*/static int mydev_open(struct inode* inode, struct file* filp);static int mydev_release(struct inode* inode, struct file* filp);static ssize_t mydev_read(struct file* filp, char __user *buf, size_t count, loff_t* f_pos);static ssize_t mydev_write(struct file* filp, const char __user *buf, size_t count, loff_t* f_pos);/**传统的设备文件操作方法表*/static struct file_operations mydev_fops = &#123; .owner = THIS_MODULE, .open = mydev_open, .release = mydev_release, .read = mydev_read, .write = mydev_write,&#125;;/*devfs文件系统的设备属性操作方法*/static ssize_t mydev_val_show(struct device* dev, struct device_attribute* attr, char* buf);static ssize_t mydev_val_store(struct device* dev, struct device_attribute* attr, const char* buf, size_t count);/*devfs文件系统的设备属性*/static DEVICE_ATTR(val, S_IRUGO | S_IWUSR, mydev_val_show, mydev_val_store);//定义传统的设备文件访问方法，主要是定义mydev_open、mydev_release、mydev_read和mydev_write这四个打开、释放、读和写设备文件的方法：/*打开设备方法*/static int mydev_open(struct inode* inode, struct file* filp) &#123; struct mydev_android_dev* dev; /*将自定义设备结构体保存在文件指针的私有数据域中，以便访问设备时拿来用*/ dev = container_of(inode-&gt;i_cdev, struct mydev_android_dev, dev); filp-&gt;private_data = dev; return 0;&#125;/*设备文件释放时调用，空实现*/static int mydev_release(struct inode* inode, struct file* filp) &#123; return 0;&#125;/*读取设备的寄存器val的值*/static ssize_t mydev_read(struct file* filp, char __user *buf, size_t count, loff_t* f_pos) &#123; ssize_t err = 0; struct mydev_android_dev* dev = filp-&gt;private_data; /*同步访问*/ if(down_interruptible(&amp;(dev-&gt;sem))) &#123; return -ERESTARTSYS; &#125; if(count &lt; sizeof(dev-&gt;val)) &#123; goto out; &#125; /*将寄存器val的值拷贝到用户提供的缓冲区*/ if(copy_to_user(buf, &amp;(dev-&gt;val), sizeof(dev-&gt;val))) &#123; err = -EFAULT; goto out; &#125; err = sizeof(dev-&gt;val);out: up(&amp;(dev-&gt;sem)); return err;&#125;/*写设备的寄存器值val*/static ssize_t mydev_write(struct file* filp, const char __user *buf, size_t count, loff_t* f_pos) &#123; struct mydev_android_dev* dev = filp-&gt;private_data; ssize_t err = 0; /*同步访问*/ if(down_interruptible(&amp;(dev-&gt;sem))) &#123; return -ERESTARTSYS; &#125; if(count != sizeof(dev-&gt;val)) &#123; goto out; &#125; /*将用户提供的缓冲区的值写到设备寄存器去*/ if(copy_from_user(&amp;(dev-&gt;val), buf, count)) &#123; err = -EFAULT; goto out; &#125; err = sizeof(dev-&gt;val);out: up(&amp;(dev-&gt;sem)); return err;&#125;//定义通过devfs文件系统访问方法，这里把设备的寄存器val看成是设备的一个属性，通过读写这个属性来对设备进行访问，主要是实现mydev_val_show和mydev_val_store两个方法，同时定义了两个内部使用的访问val值的方法__mydev_get_val和__mydev_set_val：/*读取寄存器val的值到缓冲区buf中，内部使用*/static ssize_t __mydev_get_val(struct mydev_android_dev* dev, char* buf) &#123; int val = 0; /*同步访问*/ if(down_interruptible(&amp;(dev-&gt;sem))) &#123; return -ERESTARTSYS; &#125; val = dev-&gt;val; up(&amp;(dev-&gt;sem)); return snprintf(buf, PAGE_SIZE, "%d\n", val);&#125;/*把缓冲区buf的值写到设备寄存器val中去，内部使用*/static ssize_t __mydev_set_val(struct mydev_android_dev* dev, const char* buf, size_t count) &#123; int val = 0; /*将字符串转换成数字*/ val = simple_strtol(buf, NULL, 10); /*同步访问*/ if(down_interruptible(&amp;(dev-&gt;sem))) &#123; return -ERESTARTSYS; &#125; dev-&gt;val = val; up(&amp;(dev-&gt;sem)); return count;&#125;/*读取设备属性val*/static ssize_t mydev_val_show(struct device* dev, struct device_attribute* attr, char* buf) &#123; struct mydev_android_dev* hdev = (struct mydev_android_dev*)dev_get_drvdata(dev); return __mydev_get_val(hdev, buf);&#125;/*写设备属性val*/static ssize_t mydev_val_store(struct device* dev, struct device_attribute* attr, const char* buf, size_t count) &#123; struct mydev_android_dev* hdev = (struct mydev_android_dev*)dev_get_drvdata(dev); return __mydev_set_val(hdev, buf, count);&#125;//定义通过proc文件系统访问方法，主要实现了mydev_proc_read和mydev_proc_write两个方法，同时定义了在proc文件系统创建和删除文件的方法mydev_create_proc和mydev_remove_proc：/*读取设备寄存器val的值，保存在page缓冲区中*/static ssize_t mydev_proc_read(char* page, char** start, off_t off, int count, int* eof, void* data) &#123; if(off &gt; 0) &#123; *eof = 1; return 0; &#125; return __mydev_get_val(mydev_dev, page);&#125;/*把缓冲区的值buff保存到设备寄存器val中去*/static ssize_t mydev_proc_write(struct file* filp, const char __user *buff, unsigned long len, void* data) &#123; int err = 0; char* page = NULL; if(len &gt; PAGE_SIZE) &#123; printk(KERN_ALERT"The buff is too large: %lu.\n", len); return -EFAULT; &#125; page = (char*)__get_free_page(GFP_KERNEL); if(!page) &#123; printk(KERN_ALERT"Failed to alloc page.\n"); return -ENOMEM; &#125; /*先把用户提供的缓冲区值拷贝到内核缓冲区中去*/ if(copy_from_user(page, buff, len)) &#123; printk(KERN_ALERT"Failed to copy buff from user.\n"); err = -EFAULT; goto out; &#125; err = __mydev_set_val(mydev_dev, page, len);out: free_page((unsigned long)page); return err;&#125;/*创建/proc/mydev文件*/static void mydev_create_proc(void) &#123; struct proc_dir_entry* entry; entry = create_proc_entry(MYDEV_DEVICE_PROC_NAME, 0, NULL); if(entry) &#123; entry-&gt;owner = THIS_MODULE; entry-&gt;read_proc = mydev_proc_read; entry-&gt;write_proc = mydev_proc_write; &#125;&#125;/*删除/proc/mydev文件*/static void mydev_remove_proc(void) &#123; remove_proc_entry(MYDEV_DEVICE_PROC_NAME, NULL);&#125;//最后，定义模块加载和卸载方法，这里只要是执行设备注册和初始化操作：/*初始化设备*/static int __mydev_setup_dev(struct mydev_android_dev* dev) &#123; int err; dev_t devno = MKDEV(mydev_major, mydev_minor); memset(dev, 0, sizeof(struct mydev_android_dev)); cdev_init(&amp;(dev-&gt;dev), &amp;mydev_fops); dev-&gt;dev.owner = THIS_MODULE; dev-&gt;dev.ops = &amp;mydev_fops; /*注册字符设备*/ err = cdev_add(&amp;(dev-&gt;dev),devno, 1); if(err) &#123; return err; &#125; /*初始化信号量和寄存器val的值*/ init_MUTEX(&amp;(dev-&gt;sem)); dev-&gt;val = 0; return 0;&#125;/*模块加载方法*/static int __init mydev_init(void)&#123; int err = -1; dev_t dev = 0; struct device* temp = NULL; printk(KERN_ALERT"Initializing mydev device.\n"); /*动态分配主设备和从设备号*/ err = alloc_chrdev_region(&amp;dev, 0, 1, MYDEV_DEVICE_NODE_NAME); if(err &lt; 0) &#123; printk(KERN_ALERT"Failed to alloc char dev region.\n"); goto fail; &#125; mydev_major = MAJOR(dev); mydev_minor = MINOR(dev); /*分配helo设备结构体变量*/ mydev_dev = kmalloc(sizeof(struct mydev_android_dev), GFP_KERNEL); if(!mydev_dev) &#123; err = -ENOMEM; printk(KERN_ALERT"Failed to alloc mydev_dev.\n"); goto unregister; &#125; /*初始化设备*/ err = __mydev_setup_dev(mydev_dev); if(err) &#123; printk(KERN_ALERT"Failed to setup dev: %d.\n", err); goto cleanup; &#125; /*在/sys/class/目录下创建设备类别目录mydev*/ mydev_class = class_create(THIS_MODULE, MYDEV_DEVICE_CLASS_NAME); if(IS_ERR(mydev_class)) &#123; err = PTR_ERR(mydev_class); printk(KERN_ALERT"Failed to create mydev class.\n"); goto destroy_cdev; &#125; /*在/dev/目录和/sys/class/mydev目录下分别创建设备文件mydev*/ temp = device_create(mydev_class, NULL, dev, "%s", MYDEV_DEVICE_FILE_NAME); if(IS_ERR(temp)) &#123; err = PTR_ERR(temp); printk(KERN_ALERT"Failed to create mydev device."); goto destroy_class; &#125; /*在/sys/class/mydev/mydev目录下创建属性文件val*/ err = device_create_file(temp, &amp;dev_attr_val); if(err &lt; 0) &#123; printk(KERN_ALERT"Failed to create attribute val."); goto destroy_device; &#125; dev_set_drvdata(temp, mydev_dev); /*创建/proc/mydev文件*/ mydev_create_proc(); printk(KERN_ALERT"Succedded to initialize mydev device.\n"); return 0;destroy_device: device_destroy(mydev_class, dev);destroy_class: class_destroy(mydev_class);destroy_cdev: cdev_del(&amp;(mydev_dev-&gt;dev));cleanup: kfree(mydev_dev);unregister: unregister_chrdev_region(MKDEV(mydev_major, mydev_minor), 1);fail: return err;&#125;/*模块卸载方法*/static void __exit mydev_exit(void) &#123; dev_t devno = MKDEV(mydev_major, mydev_minor); printk(KERN_ALERT"Destroy mydev device.\n"); /*删除/proc/mydev文件*/ mydev_remove_proc(); /*销毁设备类别和设备*/ if(mydev_class) &#123; device_destroy(mydev_class, MKDEV(mydev_major, mydev_minor)); class_destroy(mydev_class); &#125; /*删除字符设备和释放设备内存*/ if(mydev_dev) &#123; cdev_del(&amp;(mydev_dev-&gt;dev)); kfree(mydev_dev); &#125; /*释放设备号*/ unregister_chrdev_region(devno, 1);&#125;MODULE_LICENSE("GPL");MODULE_DESCRIPTION("Fake Register Android Driver");module_init(mydev_init);module_exit(mydev_exit); 在mydev目录中新增Kconfig和Makefile两个文件，其中Kconfig是在编译前执行配置命令make menuconfig时用到的，而Makefile是执行编译命令make是用到的 在Kconfig文件中，tristate表示编译选项MYDEV支持在编译内核时，mydev模块支持以模块、内建和不编译三种编译方法，默认是不编译，因此，在编译内核前，我们还需要执行make menuconfig命令来配置编译选项，使得mydev可以以模块或者内建的方法进行编译。在Makefile文件中，根据选项MYDEV的值，执行不同的编译方法。 Kconfig文件的内容(默认的编译方式为n，即不编译到内核中，故在编译驱动程序之前，需要执行make menuconfig命令来修改编译选项)12345config MYDEV tristate &quot;Fake Register Android Driver&quot; default n help This is the mydev driver for android system. Makefile1obj-$(CONFIG_MYDEV) += mydev.o 修改内核Kconfig文件 打开arch/arm/Kconfig文件，找到以下两行内容123menu &quot;Device Drivers&quot;......endmenu 在这两行内容之间添加下面一行内容，将驱动程序mydev和Kconfig文件包含尽量。1234menu &quot;Device Drivers&quot;source &quot;drivers/mydev/Kconfig&quot;......endmenu 这样，执行make menuconfig时，就可以配置mydev模块的编译选项了。 - 打开drivers/Kconfig，和arch/arm/Kconfig一样，增加一行内容：source &quot;drivers/mydev/Kconfig&quot; 修改drivers/Makefile文件，添加一行： 1obj-$(CONFIG_MYDEV) += mydev/ 配置编译选项： ~/Android/kernel/goldfish$ make menuconfig找到”Device Drivers” =&gt; “Fake Register Android Drivers”选项，设置为y。 注意，如果内核不支持动态加载模块，这里不能选择m，虽然我们在Kconfig文件中配置了MYDEV选项为tristate。要支持动态加载模块选项，必须要在配置菜单中选择Enable loadable module support选项；在支持动态卸载模块选项，必须要在Enable loadable module support菜单项中，选择Module unloading选项。 编译： ~/Android/kernel/goldfish$ make编译成功后，就可以在mydev目录下看到mydev.o文件了，这时候编译出来的zImage已经包含了mydev驱动。 运行新编译的内核文件，验证mydev驱动程序是否已经正常安装 ~/Android$ emulator -kernel ./kernel/goldfish/arch/arm/boot/zImage &amp; ~/Android$ adb shell 进入到dev目录，可以看到mydev设备文件 root@android:/ # cd dev root@android:/dev # ls 进入到proc目录，可以看到mydev文件： root@android:/ # cd proc root@android:/proc # ls 访问mydev文件的值 root@android:/proc # cat mydev0 root@android:/proc # echo ‘5’ &gt; mydev root@android:/proc # cat mydev5 进入到sys/class目录，可以看到mydev目录： root@android:/ # cd sys/class root@android:/sys/class # ls 进入到mydev目录，可以看到mydev目录： root@android:/sys/class # cd mydev root@android:/sys/class/mydev # ls 进入到下一层mydev目录，可以看到val文件 root@android:/sys/class/mydev # cd mydev root@android:/sys/class/mydev/mydev # ls 访问属性文件val的值 root@android:/sys/class/mydev/mydev # cat val5 root@android:/sys/class/mydev/mydev # echo ‘0’ &gt; val root@android:/sys/class/mydev/mydev # cat val0 至此，mydev内核驱动程序就完成了。这里采用的是系统提供的方法和驱动程序进行交互，也就是通过proc文件系统和devfs文件系统的方法。]]></content>
      <categories>
        <category>安卓开发</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo]]></title>
    <url>%2F2018%2F07%2F10%2F2018-07-10-hexo%2F</url>
    <content type="text"><![CDATA[hexo是一款基于Node.js的静态博客框架，可以方便的生成静态网页托管在github上。 依赖包和工具安装 Git sudo apt-get install git (git-core) git --version 生成 SSH key : ssh-keygen -t rsa -C &quot;349098792@qq.com&quot; 默认情况下连续按下三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub。如果是想一台电脑配置两个或多个github帐号，则此处不能够一直回车，要注意在提示输入文件名称时输入一个和默认名称不一样的名称，否则会发生覆盖，比如这里我电脑上使用两个github帐号，新建的一个名为yudianr，则可以给文件取名叫id_rsa_yudianr，则会在当前文件夹中生成id_rsa_yudianr和id_rsa_yudianr.pub两个文件。在GitHub帐号设置那里添加SSH Key，打开公钥文件id_rsa_yudianr.pub，复制里面的所有字符粘贴到github的SSH设置处，可使用ssh -T git@github.com来测试是否关联成功。 - 配置~/.ssh/config文件 123456789101112131415161718192021222324 #老帐号 Host github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa #新帐号 Host yudianr.github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_yudianr注意：此时提交代码后log中记录的用户名和邮箱信息都为全局配置的git帐号的信息，如果希望修改显示的信息，可以在项目目录中使用以下命令进行配置：git config --global user.name &quot;你的昵称&quot;git config --global user.email &quot;你的邮箱地址&quot;或者vim .gitconfig直接进行修改[user] name = eightplus email = kobe24_lixiang@126.com或者[user] name = yudianr email = 349098792@qq.com npm sudo apt-get install npm npm -v Nodejs sudo apt-get install nodejs node -v Hexo sudo npm install -g hexo-cli hexo -v 初始化Hexo123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 自动部署发布工具 hexo-deployer-git npm i hexo-generator-json-content –save (在上面初始化后的folder目录下打开终端执行，执行后会写入package.json文件中) 其他插件安装 123456npm i hexo-helper-qrcode --savenpm i hexo-generator-sitemap --savenpm i hexo-generator-json-feed --savenpm i hexo-generator-feed --savenpm i hexo-generator-baidu-sitemap --savenpm i hexo-deployer-rsync --save 提交搜素引擎 站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。Googlebot等搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。百度站长平台为未使用百度统计的站点提供三种验证方式：文件验证、html标签验证、CNAME验证，如果选择文件验证，下载文件后将文件放在source跟目录下。验证完成后，我们将会认为您是网站的拥有者。为使您的网站一直保持验证通过的状态，请保留验证的文件、html标签或CNAME记录，我们会去定期检查验证记录。 对谷歌和百度的插举例-&gt;打开博客根目录，在这个目录下打开终端执行执行如下两个安装插件：npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 在博客根目录的_config.yml中添加如下代码 12345# 自动生成sitemapsitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 执行hexo generate编译博客后，如果博客根目录的public下生成了sitemap.xml以及baidusitemap.xml就表示成功了。 生成静态文件 hexo generate 生成静态文件查看默认博客效果 hexo server （如果默认的4000端口被占用，可以使用-p参数指定其他端口，如：hexo server -p 5000） 修改配置 在站点的配置文件_config.yml中设置部署信息(注意：type repo branch message前有两个空格)12345deploy: type: git repo: https://github.com/eightplus/eightplus.github.io.git branch: master message: &apos;站点更新:&#123;&#123;now(&quot;YYYY-MM-DD HH:mm:ss&quot;)&#125;&#125;&apos; 部署到GitHub上12345hexo clean #清空hexo generate #生成静态网页hexo deploy #部署浏览器中输入 http://eightplus.github.io 绑定域名 在hexo的工作空间下的source目录下新建一个CNAME的文件，不要后缀。打开CNAME写上购买的域名，如： eightplus.info 扩展 网站访问量显示 使用第三方的统计插件不蒜子, 在themes\yilia\layout_partial下的footer.ejs中加入如下代码即可12345678&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;总访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次&lt;/span&gt; 实现单篇文章浏览统计和评论统计(从网易云跟帖中获取评论数) 参考文档 修改themes\yilia\layout_partial文件夹下的article.ejs文件，在&lt;%- partial(‘post/title’, {class_name: ‘article-title’}) %&gt;节点下加入(注意这里网易云跟帖还没设置，而评论数中使用到了，这里运行会有问题)显示阅读和评论数 -->1234567891011121314&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.wangYi)&#123; %&gt;&lt;br/&gt;&lt;a class=&quot;cloud-tie-join-count&quot; href=&quot;javascript:void(0);&quot; style=&quot;color:gray;font-size:14px;&quot;&gt;&lt;span class=&quot;icon-sort&quot;&gt;&lt;/span&gt;&lt;span id=&quot;busuanzi_container_page_pv&quot; style=&quot;color:#ef7522;font-size:14px;&quot;&gt; 阅读数: &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次 &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;a class=&quot;cloud-tie-join-count&quot; href=&quot;javascript:void(0);&quot; style=&quot;color:#ef7522;font-size:14px;&quot;&gt; &lt;span class=&quot;icon-comment&quot;&gt;&lt;/span&gt; &lt;span class=&quot;join-text&quot; style=&quot;color:#ef7522;font-size:14px;&quot;&gt;评论数:&lt;/span&gt; &lt;span class=&quot;join-count&quot;&gt;0&lt;/span&gt;次&lt;/a&gt;&lt;% &#125; %&gt;]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu下Android开发的基础知识]]></title>
    <url>%2F2018%2F07%2F03%2F2018-07-03-build-android%2F</url>
    <content type="text"><![CDATA[这里使用Ubuntu 16.04的64位系统上进行Android源码的编译。 一、环境准备 安装ubuntu 16.04 amd64 系统 安装Git ~$ sudo apt-get install git-core gnupg 安装Java SDK(官方JDK下载地址：http://www.oracle.com/technetwork/java/javase/downloads/index.html)： $ sudo add-apt-repository “deb http://us.archive.ubuntu.com/ubuntu/ hardy multiverse” $ sudo apt-get update $ sudo apt-get install sun-java6-jre sun-java6-plugin $ sudo apt-get install sun-java6-jdk 安装其他依赖包(valgrind为调试工具) $ sudo apt-get install flex bison gperf libsdl-dev libesd0-dev libwxgtk2.6-dev build-essential zip curl valgrind 二、下载Android源码 下载repo工具 $ wget https://dl-ssl.google.com/dl/googlesource/git-repo/repo $ chmod a+x repo $ sudo mv repo /bin/ 下载Android源码 $ mkdir Android $ cd Android Android$ repo init -u https://android.googlesource.com/platform/mainifest(如果想下载Android 2.3.1，执行：repo init -u https://android.googlesource.com/platform/mainifest -b android-2.3.1_r1) Android$ repo sync 三、编译Android源码 Android$make (make -j18)编译结果的输出目录为out/target/product/$(TARGET_PRODUCT),TARGET_PRODUCT是一个环境变量，默认值为generic 四、编译SDK(可选) Android$make sdk打包成功后，可以看到如下输出($USER$表示当前登录的用户名)：1Package SDK: out/host/linux-x86/sdk/android-sdk_eng.$USER$_linux-x86.zip 五、安装编译好的Android镜像到模拟器上 设置环境变量(Android模拟器命令emulator位于Android/out/host/linux-x86/bin中，~/Android/out/target/product/generic是Android镜像存放目录) Android$export PATH=$PATH:~/Android/out/host/linux-x86/bin Android$export ANDROID_PRODUCT_OUT=~/Android/out/target/product/generic 运行Android模拟器 Android$emulator 启动Android模拟器需要四个文件，分别为zImage、system.img、userdata.img和ramdisk.img，其中zImage为Linux内核镜像文件，三个.img文件为Android系统镜像文件。如果不带任何参数来运行emulator命令，则Android模拟器默认使用的zImage文件是Android/out/host/linux-x86/bin中的kernel-qemu文件，默认使用的三个.img文件位于ANDROID_PRODUCT_OUT目录中。ANDROID_PRODUCT_OUT是一个环境变量，这里将它的值设置为Android源码编译结果的输出目录，如果不设置ANDROID_PRODUCT_OUT环境变量，就需要指定上述四个文件来启动Android模拟器，如下： Android$emulator - kernel ./prebuilt/android-arm/kernel/kernel-qemu -sysdir ./out/target/product/generic -system system.img -data userdata.img -ramdisk ramdisk.img 六、下载、编译和安装Android最新内核源代码Android源代码工程默认是不包括它所使用的Linux内核源代码的，而是使用预先编译好的内核，即prebuilt/android-arm/kernel/kernel-qemu文件。如果我们需要运行定制的Linux内核，则需要下载Linux kernel源代码进行编译。 Linux kernel源代码下载 ~/Android$ mkdir kernel ~/Android$ cd kernel ~/Android/kernel$ git clone http://android.googlesource.com/kernel/goldfish.git 支线下载下载完成后，在kernel目录下可以看到一个空的goldfish子目录，此时需要执行git checkout来指定需要的支线代码，在执行git checkout之前，可先执行git branch -a查看有哪些支线代码。这里选择android-gldfish-2.6.29 ~/Android/kernel/goldfish$git branch -a ~/Android/kernel/goldfish$git checkout remotes/origin/archive/android-gldfish-2.6.29 修改Android内核源码目录下Makefile文件中的CROSS_COMPILE变量 1234#ARCH ?= (SUBARCH)#CROSS_COMPILE ?=ARCH ?= arm #体系结构为armCROSS_COMPILE ?= arm-eabi- #交叉编译工具链前缀 将交叉编译工具目录添加到环境变量PATH中 ~/Android/kernel/goldfish$ export PATH=$PATH:~/Android/prebuilt/linux-x86/toolchain/arm-eabi-4.4.3/bin 修改硬件配置文件goldfish_defconfig ~/Android/kernel/goldfish$ make goldfish_defconfig 开始编译(在make之前，可以执行make menuconfig先配置一下编译选项) ~/Android/kernel/goldfish$ make编译成功后，可看到下面两行：12OBJCOPY arch/arm/boot/zImageKernel: arch/arm/boot/zImage is ready 七、在模拟器中运行编译好的内核 在启动模拟器之前，先设置模拟器的目录到环境变量$PATH中去 ~/Android$export PATH=$PATH:~/Android/out/host/linux-x86/bin 设置ANDROID_PRODUCT_OUT环境变量 ~/Android$export ANDROID_PRODUCT_OUT=~/Android/out/target/product/generic 在后台中指定内核文件启动模拟器 ~/Android$emulator -kernel ./kernel/goldfish/arch/arm/boot/zImage &amp; 用adb工具连接模拟器，查看内核版本信息，看看模拟器上跑的内核是不是刚才编译出来的内核(adb位于~/Android/out/host/linux-x86/bin目录中)123~/Android$ adb shellroot@android:/ # cd procroot@android:/proc # cat version 八、单独编译Android源代码中的模块Android源码第一次执行make会耗时很久，之后如果修改了Android源码中的某个模块或者在Android源码工程新增一个自己的模块，则可以单独编译该模块，以及重新打包system.img。 在Android源码目录下的build目录下，有个脚本文件envsetup.sh，执行这个脚本文件可以获得一些有用的工具，其中就包括mmm，该命令用来编译指定目录的所有模块，通常这个目录只包含一个模块。 使用mmm命令来编译指定的模块，如Email应用程序 ~/Android$mmm packages/apps/Email/编译完成之后，就可以在out/target/product/generic/system/app目录下看到Email.apk文件了。Android系统自带的App都放在这具目录下。另外，Android系统的一些可执行文件，例如C编译的可执行文件，放在out/target/product/generic/system/bin目录下，动态链接库文件放在out/target/product/generic/system/lib目录下，out/target/product/generic/system/lib/hw目录存放的是硬件抽象层（HAL）接口文件. 编译好模块后，重新打包system.img文件 ~/Android$make snod 运行模拟器： ~/Android$emulator 九、日志系统Android系统在用户空间中提供了轻量级的logger日志系统，它是在内核中实现的一种设备驱动，与用户空间的logcat工具配合使用能够方便地跟踪调试程序。在Android系统中，分别为C/C++ 和Java语言提供两种不同的logger访问接口。C/C++日志接口一般是在编写硬件抽象层模块或者编写JNI方法时使用，而Java接口一般是在应用层编写APP时使用。 Android系统中的C/C++日志接口是通过宏来使用的。在system/core/include/android/log.h定义了日志的级别, 在system/core/include/cutils/log.h中，定义了对应的宏，如对应于ANDROID_LOG_VERBOSE的宏LOGV。如果使用C/C++日志接口，只要定义自己的LOG_TAG宏和包含头文件system/core/include/cutils/log.h就可以了。12#define LOG_TAG &quot;MY LOG TAG&quot;#include &lt;cutils/log.h&gt; 就可以了，例如使用LOGV：LOGV(“This is the log printed by LOGV in android user space.”);//ALOGI Android系统在Frameworks层中定义了Java日志接口（frameworks/base/core/java/android/util/Log.java）如果使用Java日志接口，只要在类中定义的LOG_TAG常量和引用android.util.Log就可以了。12private static final String LOG_TAG = &quot;MY_LOG_TAG&quot;;Log.i(LOG_TAG, &quot;This is the log printed by Log.i in android user space.&quot;); 要查看这些LOG的输出，可以配合logcat工具 如果是在自己编译的Android源代码工程中使用，则在后台中运行模拟器 ~/Android$ emulator &amp; 启动adb shell工具 ~/Android$ adb shell 使用logcat命令查看日志 root@android:/ # logcat]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu snap 应用]]></title>
    <url>%2F2018%2F06%2F29%2F2018-06-29-snap-qt-dbus%2F</url>
    <content type="text"><![CDATA[Ubuntu 从 16.04开始，支持两种格式的安装包：debian 和 snap，其中 snap 不依赖于操作系统及其发布版本， 其可以安装同样一个软件的不同版本且不造成任何的干扰。snap 是一种全新的软件包管理方式，它类似一个容器拥有一个应用程序所有的文件和库，各个应用程序之间完全独立，解决了应用程序之间的依赖问题，但因其包含应用需要的文件和库，导致snap包过大，占用更多的磁盘空间（snap包包含一个私有的root文件系统，里面包含了依赖的软件包）。 Snap命令简介 安装Snap的相关包 sudo apt update sudo apt-get install snapd snapcraft build-essential 在snap store中查找snap包 snap find 显示已安装的snap应用列表 snap list 安装一个snap包 sudo snap install &lt;snap_pkg_name&gt; 更新一个snap包 sudo snap refresh &lt;snap_pkg_name&gt; 将snap包还原到以前安装的版本 sudo snap revert &lt;snap_pkg_name&gt; 卸载一个snap包 sudo snap remove &lt;snap_pkg_name&gt; 打造Snap应用 我这里配置的system dbus相关的.service和.conf文件根本在snap包中没有起到作用，debian包中是可以的，原因暂时没找到比较官方的答案。最终使用plug和slot的方式，并且是手动启动system dbus的方法才让图形程序从dbus daemon获取到数据（貌似是目前snap还不支持dbus的自动启动？？？）。 1、编码编写完毕后，在源码第一级目录下打开终端，执行：$snapcraft init，会自动生成snap相关文件，其中模板文件snapcraft.yaml将描述snap包的整个构建过程 2、修改模板文件snapcraft.yaml，具体见源码中的写法 3、终端执行：$snapcraft ，生成snap包 4、安装snap包：$sudo snap install system-tool_1.0.2_amd64.snap –devmode –dangerous 5、安装完成后，终端运行 $snap interfaces 可以查看到plug和slot。有资料显示，如果要让我的dbus服务程序和图形程序进行通信，还需要终端执行：$sudo snap connect system-tool:daemon-plug system-tool:daemon-slot ，对应的disconnect操作是：$sudo snap disconnect system-tool:daemon-plug system-tool:daemon-slot。此处不执行上述操作仍可以，有些不知所依然？？？可能是我这里在snap容器中关于dbus的使用方法没找到正解的原因。 6、手动启动dbus服务，打开终端执行：$sudo system-tool.system-tool-daemon 7、启动图形程序：$system-tool图形程序运行结果图 8、如果想将自己开发的snap发布到snap商店，首先注册一个Ubuntu One帐号，注册地址 9、有了帐号之后，自然是一条流水线生产操作步骤：登录-&gt;注册应用名-&gt;上传snap包-&gt;退出 snapcraft login snapcraft register system-tool (只有第一次上传该应用时才需要注册应用名) snapcraft push system-tool_1.0.2_amd64.snap –release beta snapcraft logout 10、上传后，你可以在邮箱等着snapcraft系统给你回邮件啦！很遗憾，由于我使用了自定义的plug和slot，自动审核失败了，需要人工审核（之前验证过没有自定义slot和plug时，上传可以自动审核成功）。 参考文档https://forum.snapcraft.io/t/the-dbus-interface/2038 https://github.com/snapcore/snapd/wiki/Interfaces#dbus https://forum.snapcraft.io/t/how-do-i-connect-a-snap-to-dbus/1533 https://github.com/snapcore/snapd/pull/2592 https://blog.csdn.net/tq08g2z/article/details/78685011 https://www.2cto.com/kf/201607/528337.html https://blog.csdn.net/ubuntutouch/article/details/51886345 https://blog.csdn.net/ubuntutouch/article/details/51953272 https://www.msweet.org/blog/2018-01-23-snaps-and-gui-apps.html https://github.com/ubuntu/snappy-playpen https://code.launchpad.net/~dpm/ubuntu-calendar-app/snap-all-things]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Snap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Jekyll + Github搭建博客]]></title>
    <url>%2F2018%2F06%2F27%2F2018-06-27-welcome-to-jekyll%2F</url>
    <content type="text"><![CDATA[一直想把自己学习linux的过程记录下来，又不想总是依托那些现成的博客网站，在WordPress和Github中，我选择了Github，原因只有一个，穷，哈哈哈。这里先简要接收博客搭建的初期准备工作！Markdown编辑器使用的是Atom，快捷键列表如下： 快捷键 解释 Crtl+Shift+M 开启Markdown实时预览 Command+Shift+P 打开命令窗口，可以运行各种菜单功能 Command + T 快速多文件切换 Command + F 文件内查找和替换 Command + Shift + F 多文件查找和替换 Command + [ 对选中内容向左缩进 Command + ] 对选中内容向右缩进 Command + \ 显示或隐藏目录树 Crtl + m 相应括号之间，html tag之间等跳转 Crtl + Alt + B 格式化代码（需要安装atom-beautify） Crtl + ` 调起CLI命令行界面（需要安装terminal-panel） Github github帐号注册和创建页面仓库 注册地址：https://github.com/ 仓库的名字需要和你的账号对应，格式：yourname.github.io，比如我这里演示的页面仓库名为eightplus.github.io 生成ssh密钥，并将密钥添加到github上 生成密钥：ssh-keygen -t rsa -C 注册帐号时的邮箱地址” 密钥生成后，在 ~/.ssh目录下会生成一些文件，包括id_rsa和id_rsa.pub 打开id_rsa.pub，选中所有内容复制，网页进入 https://github.com/settings/ssh ，Add SSH key，粘贴之前复制的内容。 Github安装和帐号配置 sudo apt-get install git git config --global user.name &quot;yourname&quot; git config --global user.email &quot;注册帐号时的邮箱地址&quot; 安装ruby环境sudo apt-get install ruby-all-dev我的系统为Ubuntu 16.04，使用的软件源里面存在ruby2.3-dev，则此种方式会将ruby2.3-dev一并安装，当然，上述操作也可以替换成安装ruby2.3-dev，(sudo apt-get install ruby2.3-dev) 安装完成后，在终端中输入ruby -v，查看版本信息，如下图： 完成ruby环境后，在终端中输入gem -v，出现如下结果，则说明ruby环境已经完全配置成功了，如果出现了报错信息，可能需要安装nodejs (sudo apt-get install nodejs)。 安装JeKyll环境 先安装依赖包bundler： sudo gem install bundler 再安装安装jekyll： sudo gem install jekyll 安装完成后，在终端中输入jekyll --version，出现如下结果，则说明安装成功 工程创建是否迫不及待的想看下第一个博客的具体内容 👉 在你打算存放工程代码的目录下打开一个终端后使用jekyll创建一个项目，这里我的目录为：~/work/git/：jekyll new blog操作之后会生成很多文件/文件夹，详细说明如下： _config.yml：Jekyll配置文件，存储配置数据 _drafts：草稿目录，可手动创建 _includes：包含一些模板，可以重复利用 _layouts：存放页面模板的地方 _posts：存放文章的目录，文章格式为 mardown 格式（year-month-title.markdown）或.md，文件名确定了发表的日期和标记语言 _data：存放yaml格式的数据文件 _site：使用Jekyll编译后的静态站点将存放于这个目录下，即jekyll生成的网站会放在该文件夹下，该目录不需要push到github，可在.gitignore文件中加入这个目录 index.html：该文件带有 yaml 头信息，大概如下：123456---layout: posttitle: &quot;Welcome to Jekyll!&quot;date: 2018-06-27 15:33:17 +0800categories: jekyll update--- 上述操作会生成个默认文章，位于_posts目录下，名字类似为：2018-06-27-welcome-to-jekyll.markdown 可以复制2018-06-27-welcome-to-jekyll.markdown后进行修改来进行新的博客编写，这里推荐使用 git的atom编辑器 来编辑.markdown文件，可以在atom官网进行deb包的下载，新页面生成和编辑完成后，重启jekyll内置服务器（终端执行：jekyll serve），打开或刷新页面：http://localhost:4000，这样就可以在页面看到自己添加的博文了。 Git同步将前面创建的仓库克隆到本地，然后将blog目录中生成的文件复制到github项目目录下，我这里项目名为 eightplus.github.io。 git clone https://github.com/yourname/yourname.github.io.git git add . git commit -m &quot;init&quot; git push -u origin master 至此，在浏览器中输入https://yourname.github.io，比如：https://eightplus.github.io/，即可看到下图，博客搭建完成 网页浏览效果图]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Jekyll</tag>
      </tags>
  </entry>
</search>
