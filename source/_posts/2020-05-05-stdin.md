---
title:      "stdin 输入"
date:       2020-05-05 21:38:59
author:     "lixiang"
categories: Linux 编程
tags:
    - Qt C
---

> 使用 C 和 Qt 监控用户的终端输入(stdin)。

---


## 示例源码
- [c-stdin](https://github.com/eightplus/examples/tree/master/code/C/stdin)
- [qt-stdin](https://github.com/eightplus/examples/tree/master/code/Qt/stdin)

## 示例代码片段1

```
// Read message from stdin
void test_stdin_method1()
{
    char buf[256];
    printf("# please input your command!!!\n");
    while (fscanf(stdin, "%s", buf) > 0) {
        int op = 0;
        if (!strcmp(buf, "q")) {
            printf("Exit......\n");
            op = 1;
        }
        else {
            printf("input command `%s'\n", buf);
        }

        if(op == 1)
            break;
    }
}
```

## 示例代码片段2
```
// Read message from stdin
void test_stdin_method2()
{
    char buf[256];
    printf("# please input your command(number)!!!\n");
    while (fgets(buf, sizeof(buf), stdin) != NULL)
    {
        int iCmdType = 0;
        if(sscanf(buf, "%d", &iCmdType) == -1) {
            fprintf(stderr, "Input error: %s(errno: %d) And please input again\n", strerror(errno), errno);
            continue;
        }
        int op = 0;

        switch(iCmdType)
        {
            case 0:
                printf("Exit......\n");
                op = 1;
                break;
            default:
                printf("Command Type : %d\n", iCmdType);
                break;
        }

        if(op == 1)
            break;
    }
}
```

## 示例代码片段3

iochannel是glib中把IO事件集成到事件的一种方法，iochannel可以把发生在文件描述符、管道和socket之上的事件转换为glib的内部事件，从而可以在程序中用统一的方法来处理IO事件和用户交互。

下面表格列出的是iochannel支持的IO事件：

| IO事件         | 描述                  |
| ------------- | --------------------- |
| G_IO_IN       | 可读                   |
| G_IO_OUT      | 可写                   |
| G_IO_PRI      | 有紧急数据到达           |
| G_IO_ERR      | 出错                   |
| G_IO_HUP      | 挂断                   |
| G_IO_NVAL     | 无效请求。文件描述符未打开 |

```
typedef struct _MyData {
    gint min_number;
    gint max_number;
} MyData;

static gboolean io_watch_handle_keyboard(GIOChannel *channel, GIOCondition condition, gpointer data)
{
    gsize len = 0;
    gchar *buffer = NULL;
    MyData *m_data = (MyData *)data;

    if (g_io_channel_read_line(channel, &buffer, &len, NULL, NULL) == G_IO_STATUS_NORMAL) {
        int number = atoi(buffer);
        if (number < m_data->min_number || number > m_data->max_number) {
            g_printerr("Out of range\n");
        }
        else {
            g_print("Input Number: %d\n", number);
        }
    }

    if (len > 0) {
        g_print("Read data's length: %d\n", len);
    }
    g_free(buffer);

    return TRUE;
}

int main(int argc, char *argv[])
{
    MyData data;
    data.min_number = 0;
    data.max_number = 100;

    GMainLoop *main_loop = g_main_loop_new(NULL, FALSE);

    GIOChannel *channel;
    channel = g_io_channel_unix_new(fileno(stdin));//将标准输入描述符转化成GIOChannel
    if (channel) {
        g_io_add_watch(channel, G_IO_IN, (GIOFunc)io_watch_handle_keyboard, &data);
        g_io_channel_unref(channel);
    }

    g_main_loop_run(main_loop);
    g_main_context_unref(g_main_loop_get_context(main_loop));
    g_main_loop_unref(main_loop);

    return 0;
}
```

## 示例代码片段4
```
void start()
{
    QFile qstdin;
    qstdin.open(stdin, QIODevice::ReadOnly);
    qDebug() << "# please input your command!";
    while (true) {
        //trimmed() 去掉字符串首尾的空格; simplified()不仅去掉首尾的空格，中间连续的空格也用一个空格替换
        QString line = QString::fromLocal8Bit(qstdin.readLine()).trimmed();
        if (line.isEmpty()) {
            continue;
        }
        else if (line == "quit") {
            break;
        }
        else {
            qDebug() << line;
        }
    }

    exit(0);
}

int main(int argc, char *argv[])
{
    QCoreApplication a(argc, argv);

    start();

    return a.exec();
}
```
