{"meta":{"title":"Eight Plus","subtitle":"菜鸟的点滴记录","description":"Linux 爱好者","author":"李翔","url":"https://eightplus.github.io"},"pages":[{"title":"","date":"2018-07-18T13:36:28.000Z","updated":"2018-07-31T11:44:44.738Z","comments":true,"path":"about/index.html","permalink":"https://eightplus.github.io/about/index.html","excerpt":"","text":"关于我 在这个无常的世界里，总有一些人，会为这个世界留下些什么。而这留下的，必将成为永恒！ 一个Linux爱好者，2011年本科毕业，开始从事Linux操作系统和软件的研发，爱好开源软件开发，工作中编写的闭源软件有保密管理软件、国产征信报告查询系统、Android兼容等，熟悉的语言和框架有C/C++、Python、Shell、Qt/QML、Gtk等。 关于我的更多信息可以查看 👉Github码云"},{"title":"分类","date":"2018-07-30T10:46:20.000Z","updated":"2018-07-31T02:28:12.068Z","comments":true,"path":"categories/index.html","permalink":"https://eightplus.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-07-18T13:36:55.000Z","updated":"2018-07-31T02:28:12.068Z","comments":false,"path":"tags/index.html","permalink":"https://eightplus.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"安装Anbox","slug":"2019-08-14-install-anbox","date":"2019-08-14T13:44:03.000Z","updated":"2019-08-14T14:29:49.673Z","comments":true,"path":"2019/08/14/2019-08-14-install-anbox/","link":"","permalink":"https://eightplus.github.io/2019/08/14/2019-08-14-install-anbox/","excerpt":"","text":"Anbox是一种基于容器在常规GNU/Linux系统上启动完整Android系統的方法，如Ubuntu。Anbox 使用 Linux 命名空间机制（user，pid，uts，net，mount，ipc），在容器中运行完整的 Android 系统，容器内的 Android 没有直接访问任何硬件的权限，所有的硬件访问通过主机上的 anbox 守护进程。Anbox复用基于 QEMU 的模拟器中为 Android 所做的 OpenGL ES 加速渲染的实现。容器内的 Android 系统使用不同的管道与主机系统通信，并通过它们发送所有的硬件访问命令。 使用apt安装Anbox 安装内核模块 anbox-modules-dkms包含ashmem和binder内核模块，安装anbox-modules-dkms后，必须手动加载内核模块。下次系统启动时，它们将自动加载。 $ sudo add-apt-repository ppa:morphis/anbox-support $ sudo apt update $ sudo apt install linux-headers-generic anbox-modules-dkms $ sudo modprobe ashmem_linux $ sudo modprobe binder_linux $ ls -1 /dev/{ashmem,binder}12/dev/ashmem/dev/binder 安装和更新Anbox snap $ sudo apt install snapd $ sudo snap install --devmode --beta anbox $ snap refresh --beta --devmode anbox 查看當前可用的Anbox信息 $ snap info anbox 启动Anbox $ anbox.appmgr 安装安卓应用 $ sudo apt install android-tools-adb $ adb install my-app.apk 卸载Anbox $ snap remove anbox $ sudo apt install ppa-purge $ sudo ppa-purge ppa:morphis/anbox-support 参考文档Anbox主页 Anbox代码托管 Android 硬件 OpenGL ES 模拟设计概述 Android QEMU fast pipes The Android “qemud” multiplexing daemon Android qemud services","categories":[{"name":"安卓开发","slug":"安卓开发","permalink":"https://eightplus.github.io/categories/安卓开发/"}],"tags":[{"name":"Android Anbox","slug":"Android-Anbox","permalink":"https://eightplus.github.io/tags/Android-Anbox/"}]},{"title":"Android Binder","slug":"2018-08-11-android-binder","date":"2018-08-11T01:38:43.000Z","updated":"2018-08-11T01:56:56.719Z","comments":true,"path":"2018/08/11/2018-08-11-android-binder/","link":"","permalink":"https://eightplus.github.io/2018/08/11/2018-08-11-android-binder/","excerpt":"","text":"在Binder库中，Service组件和Client组件分别使用模板类BnInterface和BpInterface来描述，前者称为Binder本地对象，后者称为Binder代理对象。Binder库中的Binder本地对象和Binder代理对象分别对应于Binder驱动程序中的Binder实体对象和Binder引用对象。下面将简要介绍Binder进程间的通信，代码包含Server进程和Client进程，Server进程实现了一个Service组件，负责管理前面介绍的虚拟硬件设备mydev的寄存器val，并且向Client进程提供访问服务。以下将实例划分为common、server和client三个模块，其中common实现了硬件访问服务接口IMydevService，以及Binder本地对象类BnMydevService和Binder代理对象类BpMydevService；server实现了一个Server进程，里面包含一个Service组件MydevService；client实现了一个Client进程，它通过一个BpMydevService代理对象去访问运行在Server进程中的Service组件MydevService所提供的服务。 程序目录结构12345678910~/Android/external/binder----common ----IMydevgService.h ----IMydevService.cpp----server ----MydevServer.cpp ----Android.mk----client ----MydevClient.cpp ----Android.mk Server进程 common/IMydevService.h 123456789101112131415161718192021222324252627#ifndef IMYDEVSERVICE_H_#define IMYDEVSERVICE_H_#include &lt;utils/RefBase.h&gt;#include &lt;binder/IInterface.h&gt;#include &lt;binder/Parcel.h&gt;#define MYDEV_SERVICE \"com.eightplus.MydevService\" //MYDEV_SERVICE用来描述Service组件MydevService注册到Service Manager的名称using namespace android;//硬件访问服务接口class IMydevService: public IInterface&#123;public: DECLARE_META_INTERFACE(MydevService); virtual int32_t getVal() = 0;//读取虚拟硬件设备mydev中寄存器val的值 virtual void setVal(int32_t val) = 0;//向虚拟硬件设备mydev中寄存器val中写入值&#125;;//Binder本地对象类BnMydevServiceclass BnMydevService: public BnInterface&lt;IMydevService&gt;&#123;public: virtual status_t onTransact(uint32_t code, const Parcel &amp;data, Parcel *reply, uint32_t flags= 0);&#125;;#endif common/IMydevService.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#define LOG_TAG \"IMydevService\"#include &lt;utils/Log.h&gt;#include \"IMydevService.h\"using namespace android;enum&#123; GET_VAL = IBinder::First_CALL_TRANSACTION; SET_VAL = IBinder::First_CALL_TRANSACTION + 1;&#125;;class BpMydevService: public BpInterface&lt;IMydevService&gt;&#123;public: BpMydevService(const sp&lt;IBinder&gt;&amp; impl): BpInterface&lt;IMydevService&gt;(impl) &#123; &#125;public: int32_t getVal() &#123; Parcel data; data.writeInterfaceToken(IMydevService::getInterfaceDescriptor()); Parcel reply; remote()-&gt;transact(GET_VAL, data, &amp;reply); int32_t val = reply.readInt32(); return val; &#125; void setVal(int32_t val) &#123; Parcel data; data.writeInterfaceToken(IMydevService::getInterfaceDescriptor()); data.writeInt32(val); Parcel reply; remote-&gt;transact(SET_VAL, data, &amp;reply); &#125;&#125;;IMPLEMENT_META_INTERFACE(MydevService, \"com.eightplus.IMydevService\");status_t BnMydevService::onTransact(uint32_t code, const Parcel &amp;data, Parcel *reply, uint32_t flags)&#123; switch(code) &#123; case GET_VAL: &#123; CHECK_INTERFACE(IMydevService, data, reply); int32_t val = getVal(); reply-&gt;writeInt32(val); return NO_ERROR; &#125; case SET_VAL: &#123; CHECK_INTERFACE(IMydevService, data, reply); int32_t val = data.readInt32(); setVal(val); return NO_ERROR; &#125; default: &#123; return BBinder::onTransact(code, data, reply, flags); &#125; &#125;&#125; server/MydevServer.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#define LOG_TAG \"MydevServer\"#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#include &lt;utils/Log.h&gt;#include &lt;binder/IServiceManager.h&gt;#include &lt;binder/IPCThreadState.h&gt;#include \"../common/IMydevService.h\"#define MYDEV_DEVICE_NAME \"/dev/mydev\"//Service组件类MydevServiceclass MydevService: public BnMydevService&#123;public: MydevService() &#123; fd = open(MYDEV_DEVICE_NAME, O_RDWR); if(fd == -1) LOGE(\"Failed to open device %s.\\n\", MYDEV_DEVICE_NAME); &#125; virtual ~MydevService() &#123; if(fd != -1) close(fd); &#125;public: static void instantiate() &#123; defaultServiceManager()-&gt;addService(String16(MYDEV_SERVICE), new MydevService()); &#125; int32_t getVal() &#123; int32_t val = 0; if(fd != -1) read(fd, &amp;val, sizeof(val)); rerurn val; &#125; void setVal(int32_t val) &#123; if(fd != -1) write(fd, &amp;val, sizeof(val)); &#125;private: int fd;&#125;;int main(int argc, char** argv)&#123; MydevService::instantiate();//将MydevService组件注册到Service Manager中 ProcessState::self()-&gt;startThreadPool();//启动一个Binder线程池 IPCThreadState::self()-&gt;joinThreadPool();//将主线程添加到进程的Binder线程池中，用来处理来自Client进程的通信请求 return 0;&#125; server/Android.mk12345678LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE_TAGS := optionalLOCAL_SRC_FILES := ../common/IMydevService.cpp \\ MydevServer.cppLOCAL_SHARED_LIBRARIES := libcutils libutils libbinderLOCAL_PACKAGE_NAME := MydevServerinclude $(BUILD_EXECUTABLE) Client进程 client/MydevClient.cpp 1234567891011121314151617181920212223242526272829303132333435#define LOG_TAG \"MydevClient\"#include &lt;utils/Log.h&gt;#include &lt;binder/IServiceManager.h&gt;#include \"../common/IMydevService.h\"int main()&#123; sp&lt;IBinder&gt; binder = defaultServiceManager()-&gt;getService(String16(MYDEV_SERVICE)); if (binder == NULL) &#123; LOGE(\"Failed to get mydev service: %s.\\n\", MYDEV_SERVICE); return -1; &#125; sp&lt;IMydevService&gt; service = IMydevService::asInterface(binder); if (service == NULL) &#123; LOGE(\"Failed to get mydev service interface.\\n\"); return -2; &#125; printf(\"Read original value from MydevService:\\n\"); int32_t val = service-&gt;getVal(); printf(\" %d.\\n\", val);//0 printf(\"Add value 1 to MydevService.\\n\"); val += 1; service-&gt;setVal(val); printf(\"Read the value from MydevService again:\\n\"); val = service-&gt;getVal(); printf(\" %d.\\n\", val);//1 return 0;&#125; client/Android.mk12345678LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE_TAGS := optionalLOCAL_SRC_FILES := ../common/IMydevService.cpp \\ MydevClient.cppLOCAL_SHARED_LIBRARIES := libcutils libutils libbinderLOCAL_PACKAGE_NAME := MydevClientinclude $(BUILD_EXECUTABLE) 单独编译server和client ~/Android$ mmm ./external/binder/server/ ~/Android$ mmm ./external/binder/client/ 编译完成之后，就可以在out/target/product/generic/system/bin目录下看到编译结果的输出文件MydevServer和MydevClient了 重新打包system.img文件 ~/Android$make snod 运行模拟器： ~/Android$emulator -kernel kernel/goldfish/arch/arm/boot/zImage &amp; ~/Android$ adb shell root@android:/ # cd system/bin root@android:/system/bin # ./MydevServer &amp; root@android:/system/bin # ./MydevXClient12345Read original value from MydevService:0.Add value 1 to MydevService.Read the value from MydevService again:1.","categories":[{"name":"工具","slug":"工具","permalink":"https://eightplus.github.io/categories/工具/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://eightplus.github.io/tags/Android/"}]},{"title":"在Android源码中使用java编写自己的应用程序","slug":"2018-08-09-android-java-app","date":"2018-08-09T13:49:29.000Z","updated":"2018-08-09T14:18:39.241Z","comments":true,"path":"2018/08/09/2018-08-09-android-java-app/","link":"","permalink":"https://eightplus.github.io/2018/08/09/2018-08-09-android-java-app/","excerpt":"","text":"HelloWorld 程序目录结构如下： 12345678910111213~/Android/packages/experimental/HelloWorld----AndroidMainifest.xml----Android.mk----src ----com/eightplus/mydev ----HelloWorld.java----res ----layout ----main.xml ----values ----strings.xml ----drawable ----icon.png HelloWorld.java 12345678910111213141516package com.eightplus.helloimport android.app.Activity;import android.os.Bundle;import android.util.log;public class HelloWorld extends Activity &#123; private final static String LOG_TAG = \"HelloWorld\"; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); Log.i(LOG_TAG, \"HelloWorld, Welcome!!!\"); &#125;&#125; main.xml 12345678910111213&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\" android:gravity=\"center\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:gravity=\"center\" android:text=\"@string/hello_world\" &gt; &lt;/TextView&gt;&lt;/LinearLayout&gt; strings.xml 12345&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;string name=\"app_name\"&gt;HellWorld&lt;/string&gt; &lt;string name=\"hello_world\"&gt;Hello World&lt;/string&gt;&lt;/resources&gt; icon.png是应用程序的图标 AndroidMainifest.xml 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;mainifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.eightplus.hello\" android:versionCode=\"1\" android:versionName=\"1.0\"&gt; &lt;application android:icon=\"@drawable/icon\" android:label=\"@string/app_name\"&gt; &lt;activity android:name=\".HelloWorld\" android:label=\"@string/app_name\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/mainifest&gt; Android.mk 123456LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE_TAGS := optionalLOCAL_SRC_FILES := $(call all-subdir-java-files)LOCAL_PACKAGE_NAME := HelloWorldinclude $(BUILD_PACKAGE) 使用mmm命令单独编译HelloWorkd程序 ~/Android$ mmm ./packages/experimental/HelloWorld/编译完成之后，就可以在out/target/product/generic/system/app目录下看到编译结果的输出文件HelloWorld.apk了。 重新打包Android系统文件system.img ~/Android$ make snod 运行模拟器 ~/Android$ emulator Activity组件应用实例该实例由三个Acitity组件组成：MainActivity、SubActivityInProcess和SubActivityInNewProcess。MainActivity是根Acitity，SubActivityInProcess和SubActivityInNewProcess是子Acitity。MainActivity和SubActivityInProcess运行在同一个进程中，而SubActivityInNewProcess运行在一个独立的进程中。 程序目录结构如下： 12345678910111213141516~/Android/packages/experimental/Activity----AndroidMainifest.xml----Android.mk----src ----com/eightplus/activity ----MainActivity.java ----SubActivityInProcess.java ----SubActivityInNewProcess.java----res ----layout ----main.xml ----sub.xml ----values ----strings.xml ----drawable ----icon.png MainActivity.java SubActivityInProcess和SubActivityInNewProcess的组件名字分别被配置为”com.eightplus.activity.subactivity.in.process”和”com.eightplus.activity.subactivity.in.new.process”，因此调用成员和函数startActivity启动它们时，只需要分别指定这两个名称即可，不需要知道它们是哪个类来实现的。1234567891011121314151617181920212223242526272829303132333435363738394041package com.eightplus.activity; import android.app.Activity; import android.content.Intent; import android.os.Bundle; import android.util.Log; import android.view.View; import android.view.View.OnClickListener; import android.widget.Button; public class MainActivity extends Activity implements OnClickListener &#123; private final static String LOG_TAG = \"com.eightplus.activity.MainActivity\"; private Button startInProcessButton = null; private Button startInNewProcessButton = null; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); startInProcessButton = (Button)findViewById(R.id.button_start_in_process); startInNewProcessButton = (Button)findViewById(R.id.button_start_in_new_process); startInProcessButton.setOnClickListener(this); startInNewProcessButton.setOnClickListener(this); Log.i(LOG_TAG, \"Main Activity Created.\"); &#125; @Override public void onClick(View v) &#123; if(v.equals(startInProcessButton)) &#123; Intent intent = new Intent(\"com.eightplus.activity.subactivity.in.process\"); startActivity(intent); &#125; else if(v.equals(startInNewProcessButton)) &#123; Intent intent = new Intent(\"com.eightplus.activity.subactivity.in.new.process\"); startActivity(intent); &#125; &#125; &#125; SubActivityInProcess.java 1234567891011121314151617181920212223242526272829303132package com.eightplus.activity; import android.app.Activity; import android.os.Bundle; import android.util.Log; import android.view.View; import android.view.View.OnClickListener; import android.widget.Button; public class SubActivityInProcess extends Activity implements OnClickListener &#123; private final static String LOG_TAG = \"com.eightplus.activity.SubActivityInProcess\"; private Button finishButton = null; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.sub); finishButton = (Button)findViewById(R.id.button_finish); finishButton.setOnClickListener(this); Log.i(LOG_TAG, \"Sub Activity In Process Created.\"); &#125; @Override public void onClick(View v) &#123; if(v.equals(finishButton)) &#123; finish(); &#125; &#125; &#125; SubActivityInNewProcess.java 1234567891011121314151617181920212223242526272829303132package com.eightplus.activity; import android.app.Activity; import android.os.Bundle; import android.util.Log; import android.view.View; import android.view.View.OnClickListener; import android.widget.Button; public class SubActivityInNewProcess extends Activity implements OnClickListener &#123; private final static String LOG_TAG = \"com.eightplus.activity.SubActivityInNewProcess\"; private Button finishButton = null; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.sub); finishButton = (Button)findViewById(R.id.button_finish); finishButton.setOnClickListener(this); Log.i(LOG_TAG, \"Sub Activity In New Process Created.\"); &#125; @Override public void onClick(View v) &#123; if(v.equals(finishButton)) &#123; finish(); &#125; &#125; &#125; main.xml 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\" android:gravity=\"center\"&gt; &lt;Button android:id=\"@+id/button_start_in_process\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:gravity=\"center\" android:text=\"@string/start_in_process\" &gt; &lt;/Button&gt; &lt;Button android:id=\"@+id/button_start_in_new_process\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:gravity=\"center\" android:text=\"@string/start_in_new_process\" &gt; &lt;/Button&gt;&lt;/LinearLayout&gt; sub.xml 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\" android:gravity=\"center\"&gt; &lt;Button android:id=\"@+id/button_finish\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:gravity=\"center\" android:text=\"@string/finish\" &gt; &lt;/Button&gt;&lt;/LinearLayout&gt; strings.xml 12345678&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;string name=\"app_name\"&gt;Activity&lt;/string&gt; &lt;string name=\"sub_activity\"&gt;Sub Activity&lt;/string&gt; &lt;string name=\"start_in_process\"&gt;Start sub-activity in process&lt;/string&gt; &lt;string name=\"start_in_new_process\"&gt;Start sub-activity in new process&lt;/string&gt; &lt;string name=\"finish\"&gt;Finish activity&lt;/string&gt;&lt;/resources&gt; icon.png为应用程序的图标 AndroidMainifest.xml 1234567891011121314151617181920212223242526272829303132&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.eightplus.activity\" android:versionCode=\"1\" android:versionName=\"1.0\"&gt; &lt;application android:icon=\"@drawable/icon\" android:label=\"@string/app_name\"&gt; &lt;activity android:name=\".MainActivity\" android:label=\"@string/app_name\" android:process=\"com.eightplus.activity.mainprocess\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:label=\"@string/sub_activity\" android:name=\".SubActivityInProcess\" android:process=\"com.eightplus.activity.mainprocess\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.eightplus.activity.subactivity.in.process\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:label=\"@string/sub_activity\" android:name=\".SubActivityInNewProcess\" android:process=\"com.eightplus.activity.newprocess\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.eightplus.activity.subactivity.in.new.process\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; Android.mk 123456LOCAL_PATH:= $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE_TAGS := optionalLOCAL_SRC_FILES := $(call all-subdir-java-files)LOCAL_PACKAGE_NAME := Activityinclude $(BUILD_PACKAGE) 编译和打包 ~/Android$ mmm packages/experimental/Activity ~/Android$ make snod 启动模拟器 ~/Android$ emulator Service组件应用实例该实例由一个Service组件CounterService和一个Activity组件Counter组成。CounterService组件实现了一个计数器服务，它是由Counter组件启动起来的，并且与Counter组件绑定在一起。CounterService组件在内部使用一个异步任务(AsyncTask)来实现一个计数器，每隔一秒就将内部的计数加1,并且实时地将这个计数显示在Counter组件的用户界面上。由于计数器需要不停地执行加数功能，所以这里将它放在一个后台程序中运行，避免Counter组件不能及时地响应用户界面事件。 程序目录结构如下： 1234567891011121314151617~/Android/packages/experimental/Counter----AndroidMainifest.xml----Android.mk----src ----com/eightplus/counter ----ICounterCallback.java ----ICounterService.java ----CounterService.java ----Counter.java----res ----layout ----main.xml ----sub.xml ----values ----strings.xml ----drawable ----icon.png ICounterCallback.java 12345package com.eightplus.counterpublicd interface ICounterCallback &#123; void count(int val);&#125; ICounterService.java 123456package com.eightplus.counterpublicd interface ICounterService &#123; public void startCounter(int initVal, ICounterCallback callback); public void stopCounter();&#125; CounterService.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.eightplus.counterimport android.app.Service;import android.content.Intent;import android.os.AsyncTask;import android.os.Binder;import android.os.IBinder;import android.util.Log;public class CounterService extends Service implements ICounterService &#123; private final static String LOG_TAG = \"com.eightplus.activity.CounterService\"; private bool stop = false; private ICounterCallback counterCallback = null; private final IBinder binder = new CounterBinder(); public class CounterBinder extends Binder &#123; public CounterService getService() &#123; return CounterService.this; &#125; &#125; @Override public IBinder onBind(Intent intent) &#123; return binder; &#125; @Override public void onCreate() &#123; super.onCreate(); Log.i(LOG_TAG, \"Counter Service Created.\"); &#125; public void startCounter(int initVal, ICounterCallback callback) &#123; counterCallback = callback; AsyncTask&lt;Integer, Integer, Integer&gt; task = new AsyncTask&lt;Integer, Integer, Integer&gt;() &#123; @Override protected Integer doInBackground(Integer... vals) &#123; Integer initCounter = vals[0]; stop = false; while(!stop) &#123; publishProcess(initCounter); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; initCounter++; &#125; return initCounter; &#125; @Override protected void onProgressUpdate(Integer... values) &#123; super.onProgressUpdate(values); int val = values[0]; counterCallback.count(val); &#125; @Override protected void onPostExecute(Integer val) &#123; counterCallback.count(val); &#125; &#125;; task.execute(initVal); &#125; public void stopCounter() &#123; stop = true; &#125;&#125; Counter.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package com.eightplus.counterimport android.app.Activity;import android.content.ComponentName;import android.content.Context;import android.content.Intent;import android.content.IntentFilter;import android.content.ServiceConnection;import android.os.Bundle;import android.os.IBinder;import android.util.Log;import android.view.View;import android.view.onClickListener;import android.widget.Button;import android.widget.TextView;public class Counter extends Activity implements OnClickListener, ICounterCallback &#123; private final static String LOG_TAG = \"com.eightplus.activity.Counter\"; private Button startButton = null; private Button stopButton = null; private TextView counterText = null; private ICounterService counterService = null; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); startButton = (Button)findViewById(R.id.button_start); stopButton = (Button)findViewById(R.id.button_stop); counterText = (TextView)findViewById(R.id.textview_counter); startButton.setOnClickListener(this); stopButton.setOnClickListener(this); startButton.setEnabled(true); stopButton.setEnabled(false); Intent bindIntent = new Intent(Counter.this, CounterService.class); bindService(bindIntent, serviceConnection, Context.BIND_AUTO_CREATE); Log.i(LOG_TAG, \"Counter Activity Created.\"); &#125; @Override public void onDestroy() &#123; super.onDestory(); unbindService(serviceConnection); &#125; @Override public void onClick(View v) &#123; if(v.equals(startButton)) &#123; if (counterService != null) &#123; counterService.startCounter(0, this); startButton.setEnabled(false); stopButton.setEnabled(true); &#125; &#125; else if(v.equals(stopButton)) &#123; if (counterService != null) &#123; counterService.stopCounter(); startButton.setEnabled(true); stopButton.setEnabled(false); &#125; &#125; &#125; @Override public void count(int val) &#123; String text = String.valueOf(val); counterText.setText(text); &#125; private ServiceConnection serviceConnection = new ServiceConnection() &#123; public void onServiceConnected(ComponentName className, IBinder service) &#123; counterService = ((CounterService.CounterBinder)service).getService(); Log.i(LOG_TAG, \"Counter Service Connected\"); &#125; public void onServiceDisconnected(ComponentName className) &#123; counterService = null; Log.i(LOG_TAG, \"Counter Service DisConnected\"); &#125;&#125; main.xml 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\" android:gravity=\"center\"&gt; &lt;LinearLayout android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:layout_marginBottom=\"10px\" android:orientation=\"horizontal\" android:gravity=\"center\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginBottom=\"4px\" android:gravity=\"center\" android:text=\"@string/counter\"&gt; &lt;/TextView&gt; &lt;TextView android:id=\"@+id/textview_counter\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:gravity=\"center\" android:text=\"@string/init_counter\"&gt; &lt;/TextView&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:orientation=\"horizontal\" android:gravity=\"center\"&gt; &lt;Button android:id=\"@+id/button_start\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:gravity=\"center\" android:text=\"@string/start\"&gt; &lt;/Button&gt; &lt;Button android:id=\"@+id/button_stop\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:gravity=\"center\" android:text=\"@string/stop\"&gt; &lt;/Button&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; strings.xml 12345678&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;string name=\"app_name\"&gt;Counter&lt;/string&gt; &lt;string name=\"counter\"&gt;Counter:&lt;/string&gt; &lt;string name=\"init_counter\"&gt;0&lt;/string&gt; &lt;string name=\"start\"&gt;Start Counter&lt;/string&gt; &lt;string name=\"stop\"&gt;Stop Counter&lt;/string&gt;&lt;/resources&gt; icon.png为应用程序的图标 AndroidMainifest.xml 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.eightplus.counter\" android:versionCode=\"1\" android:versionName=\"1.0\"&gt; &lt;application android:icon=\"@drawable/icon\" android:label=\"@string/app_name\"&gt; &lt;activity android:name=\".Counter\" android:label=\"@string/app_name\" &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;service android:name=\".CounterService\" android:enabled=\"true\"&gt; &lt;/service&gt; &lt;/application&gt;&lt;/manifest&gt; Android.mk 123456LOCAL_PATH:= $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE_TAGS := optionalLOCAL_SRC_FILES := $(call all-subdir-java-files)LOCAL_PACKAGE_NAME := Counterinclude $(BUILD_PACKAGE) 编译和打包 ~/Android$ mmm ./packages/experimental/Counter/ ~/Android$ make snod 启动模拟器 ~/Android$ emulator","categories":[{"name":"工具","slug":"工具","permalink":"https://eightplus.github.io/categories/工具/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://eightplus.github.io/tags/Android/"}]},{"title":"在Android源码中编写C程序测试Linux内核驱动程序","slug":"2018-08-06-test-android-kernel-driver-program","date":"2018-08-06T14:33:11.000Z","updated":"2018-08-06T14:49:11.803Z","comments":true,"path":"2018/08/06/2018-08-06-test-android-kernel-driver-program/","link":"","permalink":"https://eightplus.github.io/2018/08/06/2018-08-06-test-android-kernel-driver-program/","excerpt":"","text":"在mydev的Linux内核驱动程序中，创建三个不同的文件节点来供用户空间访问，分别是传统的设备文件/dev/mydev、proc系统文件/proc/mydev和devfs系统属性文件/sys/class/mydev/mydev/val。这里通过编写的C可执行程序来访问设备文件/dev/mydev。 驱动程序目录结构如下： 12345~/Android----external ----mydev ----mydev.c ----Android.mk 使用Android模拟器加载包含这个Linux驱动程序的内核文件，并且使用adb shell命令连接上模拟，验证在/dev目录中存在设备文件mydev。 进入到Android源代码工程的external目录，创建mydev目录 ~/Android$ cd external ~/Android/external$ mkdir mydev 在mydev目录中新建mydev.c文件 打开/dev/mydev文件，然后先读出/dev/mydev文件中的值，接着写入值5到/dev/mydev中去，最后再次读出/dev/mydev文件中的值，看看是否是我们刚才写入的值5。从/dev/mydev文件读写的值实际上就是我们虚拟的硬件的寄存器val的值。 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;fcntl.h&gt;#define DEVICE_NAME \"/dev/mydev\"int main(int argc, char** argv)&#123; int fd = -1; int val = 0; fd = open(DEVICE_NAME, O_RDWR); if(fd == -1) &#123; printf(\"Failed to open device %s.\\n\", DEVICE_NAME); return -1; &#125; printf(\"Read original value:\\n\"); read(fd, &amp;val, sizeof(val)); printf(\"%d.\\n\\n\", val); val = 5; printf(\"Write value %d to %s.\\n\\n\", val, DEVICE_NAME); write(fd, &amp;val, sizeof(val)); printf(\"Read the value again:\\n\"); read(fd, &amp;val, sizeof(val)); printf(\"%d.\\n\\n\", val); close(fd); return 0;&#125; 在mydev目录中新建Android.mk文件，其中“BUILD_EXECUTABLE”表示编译的是可执行程序 123456LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE_TAGS := optionalLOCAL_MODULE := mydevLOCAL_SRC_FILES := $(call all-subdir-c-files)include $(BUILD_EXECUTABLE) 使用mmm命令进行编译 ~/Android$ mmm ./external/mydev若编译成功，则可以在out/target/product/gerneric/system/bin目录下看到可执行文件mydev。 重新打包Android系统文件system.img，重新打包后的system.img文件包含了刚才编译好的mydev可执行文件。 ~/Android$ make snod 运行模拟器，使用/system/bin/mydev可执行程序来访问Linux内核驱动程序 ~/Android$ emulator -kernel ./kernel/goldfish/arch/arm/boot/zImage &amp; ~/Android$ adb shell root@android:/ # cd system/bin root@android:/system/bin # ./mydev12345Read the original value:0.Write value 5 to /dev/mydev.Read the value again:5.","categories":[{"name":"工具","slug":"工具","permalink":"https://eightplus.github.io/categories/工具/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://eightplus.github.io/tags/Android/"}]},{"title":"为Android系统编写Linux内核驱动程序","slug":"2018-08-02-android-kernel-driver","date":"2018-08-02T01:04:36.000Z","updated":"2018-08-06T14:37:24.543Z","comments":true,"path":"2018/08/02/2018-08-02-android-kernel-driver/","link":"","permalink":"https://eightplus.github.io/2018/08/02/2018-08-02-android-kernel-driver/","excerpt":"","text":"这里使用一个虚拟的硬件设备，这个设备只有一个4字节的寄存器，它可读可写。这里把这个虚拟的设备命名为“mydev”，而这个内核驱动程序也命名为mydev驱动程序。这里通过cat命令直接访问/proc/mydev和/sys/class/mydev/mydev/val文件验证驱动程序的正确性。 驱动程序目录结构如下： 1234567~/Android/kernel/goldfish----drivers ----mydev ----mydev.h ----mydev.c ----Kconfig ----Makefile 新建mydev目录 ~/Android$ cd kernel/goldfish/drivers ~/Android/kernel/goldfish/drivers$ mkdir mydev 在mydev目录中增加mydev.h文件 123456789101112131415161718#ifndef _MYDEV_ANDROID_H_#define _MYDEV_ANDROID_Hpp#include &lt;linux/cdev.h&gt;#include &lt;linux/semaphore.h&gt;#define MYDEV_DEVICE_NODE_NAME \"helmydevlo\"#define MYDEV_DEVICE_FILE_NAME \"mydev\"#define MYDEV_DEVICE_PROC_NAME \"mydev\"#define MYDEV_DEVICE_CLASS_NAME \"mydev\"//字符设备结构体struct mydev_android_dev &#123; int val;//寄存器 struct semaphore sem;//信号量 struct cdev dev;//内嵌的字符设备&#125;;#endif 在mydev目录中增加mydev.c文件，这是驱动程序的实现部分。驱动程序的功能主要是向上层提供访问设备的寄存器的值，包括读和写。这里，提供了三种访问设备寄存器的方法，一是通过proc文件系统来访问，二是通过传统的设备文件的方法来访问，三是通过devfs文件系统来访问。下面分段描述该驱动程序的实现。 首先是包含必要的头文件和定义三种访问设备的方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359#include &lt;linux/init.h&gt;#include &lt;linux/module.h&gt;#include &lt;linux/types.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/proc_fs.h&gt;#include &lt;linux/device.h&gt;#include &lt;asm/uaccess.h&gt;#include \"mydev.h\"/*主设备和从设备号变量*/static int mydev_major = 0;static int mydev_minor = 0;/*设备类别和设备变量*/static struct class* mydev_class = NULL;static struct mydev_android_dev* mydev_dev = NULL;/*传统的设备文件操作方法*/static int mydev_open(struct inode* inode, struct file* filp);static int mydev_release(struct inode* inode, struct file* filp);static ssize_t mydev_read(struct file* filp, char __user *buf, size_t count, loff_t* f_pos);static ssize_t mydev_write(struct file* filp, const char __user *buf, size_t count, loff_t* f_pos);/**传统的设备文件操作方法表*/static struct file_operations mydev_fops = &#123; .owner = THIS_MODULE, .open = mydev_open, .release = mydev_release, .read = mydev_read, .write = mydev_write,&#125;;/*devfs文件系统的设备属性操作方法*/static ssize_t mydev_val_show(struct device* dev, struct device_attribute* attr, char* buf);static ssize_t mydev_val_store(struct device* dev, struct device_attribute* attr, const char* buf, size_t count);/*devfs文件系统的设备属性*/static DEVICE_ATTR(val, S_IRUGO | S_IWUSR, mydev_val_show, mydev_val_store);//定义传统的设备文件访问方法，主要是定义mydev_open、mydev_release、mydev_read和mydev_write这四个打开、释放、读和写设备文件的方法：/*打开设备方法*/static int mydev_open(struct inode* inode, struct file* filp) &#123; struct mydev_android_dev* dev; /*将自定义设备结构体保存在文件指针的私有数据域中，以便访问设备时拿来用*/ dev = container_of(inode-&gt;i_cdev, struct mydev_android_dev, dev); filp-&gt;private_data = dev; return 0;&#125;/*设备文件释放时调用，空实现*/static int mydev_release(struct inode* inode, struct file* filp) &#123; return 0;&#125;/*读取设备的寄存器val的值*/static ssize_t mydev_read(struct file* filp, char __user *buf, size_t count, loff_t* f_pos) &#123; ssize_t err = 0; struct mydev_android_dev* dev = filp-&gt;private_data; /*同步访问*/ if(down_interruptible(&amp;(dev-&gt;sem))) &#123; return -ERESTARTSYS; &#125; if(count &lt; sizeof(dev-&gt;val)) &#123; goto out; &#125; /*将寄存器val的值拷贝到用户提供的缓冲区*/ if(copy_to_user(buf, &amp;(dev-&gt;val), sizeof(dev-&gt;val))) &#123; err = -EFAULT; goto out; &#125; err = sizeof(dev-&gt;val);out: up(&amp;(dev-&gt;sem)); return err;&#125;/*写设备的寄存器值val*/static ssize_t mydev_write(struct file* filp, const char __user *buf, size_t count, loff_t* f_pos) &#123; struct mydev_android_dev* dev = filp-&gt;private_data; ssize_t err = 0; /*同步访问*/ if(down_interruptible(&amp;(dev-&gt;sem))) &#123; return -ERESTARTSYS; &#125; if(count != sizeof(dev-&gt;val)) &#123; goto out; &#125; /*将用户提供的缓冲区的值写到设备寄存器去*/ if(copy_from_user(&amp;(dev-&gt;val), buf, count)) &#123; err = -EFAULT; goto out; &#125; err = sizeof(dev-&gt;val);out: up(&amp;(dev-&gt;sem)); return err;&#125;//定义通过devfs文件系统访问方法，这里把设备的寄存器val看成是设备的一个属性，通过读写这个属性来对设备进行访问，主要是实现mydev_val_show和mydev_val_store两个方法，同时定义了两个内部使用的访问val值的方法__mydev_get_val和__mydev_set_val：/*读取寄存器val的值到缓冲区buf中，内部使用*/static ssize_t __mydev_get_val(struct mydev_android_dev* dev, char* buf) &#123; int val = 0; /*同步访问*/ if(down_interruptible(&amp;(dev-&gt;sem))) &#123; return -ERESTARTSYS; &#125; val = dev-&gt;val; up(&amp;(dev-&gt;sem)); return snprintf(buf, PAGE_SIZE, \"%d\\n\", val);&#125;/*把缓冲区buf的值写到设备寄存器val中去，内部使用*/static ssize_t __mydev_set_val(struct mydev_android_dev* dev, const char* buf, size_t count) &#123; int val = 0; /*将字符串转换成数字*/ val = simple_strtol(buf, NULL, 10); /*同步访问*/ if(down_interruptible(&amp;(dev-&gt;sem))) &#123; return -ERESTARTSYS; &#125; dev-&gt;val = val; up(&amp;(dev-&gt;sem)); return count;&#125;/*读取设备属性val*/static ssize_t mydev_val_show(struct device* dev, struct device_attribute* attr, char* buf) &#123; struct mydev_android_dev* hdev = (struct mydev_android_dev*)dev_get_drvdata(dev); return __mydev_get_val(hdev, buf);&#125;/*写设备属性val*/static ssize_t mydev_val_store(struct device* dev, struct device_attribute* attr, const char* buf, size_t count) &#123; struct mydev_android_dev* hdev = (struct mydev_android_dev*)dev_get_drvdata(dev); return __mydev_set_val(hdev, buf, count);&#125;//定义通过proc文件系统访问方法，主要实现了mydev_proc_read和mydev_proc_write两个方法，同时定义了在proc文件系统创建和删除文件的方法mydev_create_proc和mydev_remove_proc：/*读取设备寄存器val的值，保存在page缓冲区中*/static ssize_t mydev_proc_read(char* page, char** start, off_t off, int count, int* eof, void* data) &#123; if(off &gt; 0) &#123; *eof = 1; return 0; &#125; return __mydev_get_val(mydev_dev, page);&#125;/*把缓冲区的值buff保存到设备寄存器val中去*/static ssize_t mydev_proc_write(struct file* filp, const char __user *buff, unsigned long len, void* data) &#123; int err = 0; char* page = NULL; if(len &gt; PAGE_SIZE) &#123; printk(KERN_ALERT\"The buff is too large: %lu.\\n\", len); return -EFAULT; &#125; page = (char*)__get_free_page(GFP_KERNEL); if(!page) &#123; printk(KERN_ALERT\"Failed to alloc page.\\n\"); return -ENOMEM; &#125; /*先把用户提供的缓冲区值拷贝到内核缓冲区中去*/ if(copy_from_user(page, buff, len)) &#123; printk(KERN_ALERT\"Failed to copy buff from user.\\n\"); err = -EFAULT; goto out; &#125; err = __mydev_set_val(mydev_dev, page, len);out: free_page((unsigned long)page); return err;&#125;/*创建/proc/mydev文件*/static void mydev_create_proc(void) &#123; struct proc_dir_entry* entry; entry = create_proc_entry(MYDEV_DEVICE_PROC_NAME, 0, NULL); if(entry) &#123; entry-&gt;owner = THIS_MODULE; entry-&gt;read_proc = mydev_proc_read; entry-&gt;write_proc = mydev_proc_write; &#125;&#125;/*删除/proc/mydev文件*/static void mydev_remove_proc(void) &#123; remove_proc_entry(MYDEV_DEVICE_PROC_NAME, NULL);&#125;//最后，定义模块加载和卸载方法，这里只要是执行设备注册和初始化操作：/*初始化设备*/static int __mydev_setup_dev(struct mydev_android_dev* dev) &#123; int err; dev_t devno = MKDEV(mydev_major, mydev_minor); memset(dev, 0, sizeof(struct mydev_android_dev)); cdev_init(&amp;(dev-&gt;dev), &amp;mydev_fops); dev-&gt;dev.owner = THIS_MODULE; dev-&gt;dev.ops = &amp;mydev_fops; /*注册字符设备*/ err = cdev_add(&amp;(dev-&gt;dev),devno, 1); if(err) &#123; return err; &#125; /*初始化信号量和寄存器val的值*/ init_MUTEX(&amp;(dev-&gt;sem)); dev-&gt;val = 0; return 0;&#125;/*模块加载方法*/static int __init mydev_init(void)&#123; int err = -1; dev_t dev = 0; struct device* temp = NULL; printk(KERN_ALERT\"Initializing mydev device.\\n\"); /*动态分配主设备和从设备号*/ err = alloc_chrdev_region(&amp;dev, 0, 1, MYDEV_DEVICE_NODE_NAME); if(err &lt; 0) &#123; printk(KERN_ALERT\"Failed to alloc char dev region.\\n\"); goto fail; &#125; mydev_major = MAJOR(dev); mydev_minor = MINOR(dev); /*分配helo设备结构体变量*/ mydev_dev = kmalloc(sizeof(struct mydev_android_dev), GFP_KERNEL); if(!mydev_dev) &#123; err = -ENOMEM; printk(KERN_ALERT\"Failed to alloc mydev_dev.\\n\"); goto unregister; &#125; /*初始化设备*/ err = __mydev_setup_dev(mydev_dev); if(err) &#123; printk(KERN_ALERT\"Failed to setup dev: %d.\\n\", err); goto cleanup; &#125; /*在/sys/class/目录下创建设备类别目录mydev*/ mydev_class = class_create(THIS_MODULE, MYDEV_DEVICE_CLASS_NAME); if(IS_ERR(mydev_class)) &#123; err = PTR_ERR(mydev_class); printk(KERN_ALERT\"Failed to create mydev class.\\n\"); goto destroy_cdev; &#125; /*在/dev/目录和/sys/class/mydev目录下分别创建设备文件mydev*/ temp = device_create(mydev_class, NULL, dev, \"%s\", MYDEV_DEVICE_FILE_NAME); if(IS_ERR(temp)) &#123; err = PTR_ERR(temp); printk(KERN_ALERT\"Failed to create mydev device.\"); goto destroy_class; &#125; /*在/sys/class/mydev/mydev目录下创建属性文件val*/ err = device_create_file(temp, &amp;dev_attr_val); if(err &lt; 0) &#123; printk(KERN_ALERT\"Failed to create attribute val.\"); goto destroy_device; &#125; dev_set_drvdata(temp, mydev_dev); /*创建/proc/mydev文件*/ mydev_create_proc(); printk(KERN_ALERT\"Succedded to initialize mydev device.\\n\"); return 0;destroy_device: device_destroy(mydev_class, dev);destroy_class: class_destroy(mydev_class);destroy_cdev: cdev_del(&amp;(mydev_dev-&gt;dev));cleanup: kfree(mydev_dev);unregister: unregister_chrdev_region(MKDEV(mydev_major, mydev_minor), 1);fail: return err;&#125;/*模块卸载方法*/static void __exit mydev_exit(void) &#123; dev_t devno = MKDEV(mydev_major, mydev_minor); printk(KERN_ALERT\"Destroy mydev device.\\n\"); /*删除/proc/mydev文件*/ mydev_remove_proc(); /*销毁设备类别和设备*/ if(mydev_class) &#123; device_destroy(mydev_class, MKDEV(mydev_major, mydev_minor)); class_destroy(mydev_class); &#125; /*删除字符设备和释放设备内存*/ if(mydev_dev) &#123; cdev_del(&amp;(mydev_dev-&gt;dev)); kfree(mydev_dev); &#125; /*释放设备号*/ unregister_chrdev_region(devno, 1);&#125;MODULE_LICENSE(\"GPL\");MODULE_DESCRIPTION(\"Fake Register Android Driver\");module_init(mydev_init);module_exit(mydev_exit); 在mydev目录中新增Kconfig和Makefile两个文件，其中Kconfig是在编译前执行配置命令make menuconfig时用到的，而Makefile是执行编译命令make是用到的 在Kconfig文件中，tristate表示编译选项MYDEV支持在编译内核时，mydev模块支持以模块、内建和不编译三种编译方法，默认是不编译，因此，在编译内核前，我们还需要执行make menuconfig命令来配置编译选项，使得mydev可以以模块或者内建的方法进行编译。在Makefile文件中，根据选项MYDEV的值，执行不同的编译方法。 Kconfig文件的内容(默认的编译方式为n，即不编译到内核中，故在编译驱动程序之前，需要执行make menuconfig命令来修改编译选项)12345config MYDEV tristate &quot;Fake Register Android Driver&quot; default n help This is the mydev driver for android system. Makefile1obj-$(CONFIG_MYDEV) += mydev.o 修改内核Kconfig文件 打开arch/arm/Kconfig文件，找到以下两行内容123menu &quot;Device Drivers&quot;......endmenu 在这两行内容之间添加下面一行内容，将驱动程序mydev和Kconfig文件包含尽量。1234menu &quot;Device Drivers&quot;source &quot;drivers/mydev/Kconfig&quot;......endmenu 这样，执行make menuconfig时，就可以配置mydev模块的编译选项了。 - 打开drivers/Kconfig，和arch/arm/Kconfig一样，增加一行内容：source &quot;drivers/mydev/Kconfig&quot; 修改drivers/Makefile文件，添加一行： 1obj-$(CONFIG_MYDEV) += mydev/ 配置编译选项： ~/Android/kernel/goldfish$ make menuconfig找到”Device Drivers” =&gt; “Fake Register Android Drivers”选项，设置为y。 注意，如果内核不支持动态加载模块，这里不能选择m，虽然我们在Kconfig文件中配置了MYDEV选项为tristate。要支持动态加载模块选项，必须要在配置菜单中选择Enable loadable module support选项；在支持动态卸载模块选项，必须要在Enable loadable module support菜单项中，选择Module unloading选项。 编译： ~/Android/kernel/goldfish$ make编译成功后，就可以在mydev目录下看到mydev.o文件了，这时候编译出来的zImage已经包含了mydev驱动。 运行新编译的内核文件，验证mydev驱动程序是否已经正常安装 ~/Android$ emulator -kernel ./kernel/goldfish/arch/arm/boot/zImage &amp; ~/Android$ adb shell 进入到dev目录，可以看到mydev设备文件 root@android:/ # cd dev root@android:/dev # ls 进入到proc目录，可以看到mydev文件： root@android:/ # cd proc root@android:/proc # ls 访问mydev文件的值 root@android:/proc # cat mydev0 root@android:/proc # echo ‘5’ &gt; mydev root@android:/proc # cat mydev5 进入到sys/class目录，可以看到mydev目录： root@android:/ # cd sys/class root@android:/sys/class # ls 进入到mydev目录，可以看到mydev目录： root@android:/sys/class # cd mydev root@android:/sys/class/mydev # ls 进入到下一层mydev目录，可以看到val文件 root@android:/sys/class/mydev # cd mydev root@android:/sys/class/mydev/mydev # ls 访问属性文件val的值 root@android:/sys/class/mydev/mydev # cat val5 root@android:/sys/class/mydev/mydev # echo ‘0’ &gt; val root@android:/sys/class/mydev/mydev # cat val0 至此，mydev内核驱动程序就完成了。这里采用的是系统提供的方法和驱动程序进行交互，也就是通过proc文件系统和devfs文件系统的方法。","categories":[{"name":"工具","slug":"工具","permalink":"https://eightplus.github.io/categories/工具/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://eightplus.github.io/tags/Android/"}]},{"title":"Hexo","slug":"2018-07-10-hexo","date":"2018-07-10T08:25:16.000Z","updated":"2018-07-31T09:54:19.214Z","comments":true,"path":"2018/07/10/2018-07-10-hexo/","link":"","permalink":"https://eightplus.github.io/2018/07/10/2018-07-10-hexo/","excerpt":"","text":"hexo是一款基于Node.js的静态博客框架，可以方便的生成静态网页托管在github上。 依赖包和工具安装 Git sudo apt-get install git (git-core) git --version 生成 SSH key : ssh-keygen -t rsa -C &quot;349098792@qq.com&quot; 默认情况下连续按下三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub。如果是想一台电脑配置两个或多个github帐号，则此处不能够一直回车，要注意在提示输入文件名称时输入一个和默认名称不一样的名称，否则会发生覆盖，比如这里我电脑上使用两个github帐号，新建的一个名为yudianr，则可以给文件取名叫id_rsa_yudianr，则会在当前文件夹中生成id_rsa_yudianr和id_rsa_yudianr.pub两个文件。在GitHub帐号设置那里添加SSH Key，打开公钥文件id_rsa_yudianr.pub，复制里面的所有字符粘贴到github的SSH设置处，可使用ssh -T git@github.com来测试是否关联成功。 - 配置~/.ssh/config文件 123456789101112131415161718192021222324 #老帐号 Host github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa #新帐号 Host yudianr.github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_yudianr注意：此时提交代码后log中记录的用户名和邮箱信息都为全局配置的git帐号的信息，如果希望修改显示的信息，可以在项目目录中使用以下命令进行配置：git config --global user.name &quot;你的昵称&quot;git config --global user.email &quot;你的邮箱地址&quot;或者vim .gitconfig直接进行修改[user] name = eightplus email = kobe24_lixiang@126.com或者[user] name = yudianr email = 349098792@qq.com npm sudo apt-get install npm npm -v Nodejs sudo apt-get install nodejs node -v Hexo sudo npm install -g hexo-cli hexo -v 初始化Hexo123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 自动部署发布工具 hexo-deployer-git npm i hexo-generator-json-content –save (在上面初始化后的folder目录下打开终端执行，执行后会写入package.json文件中) 其他插件安装 123456npm i hexo-helper-qrcode --savenpm i hexo-generator-sitemap --savenpm i hexo-generator-json-feed --savenpm i hexo-generator-feed --savenpm i hexo-generator-baidu-sitemap --savenpm i hexo-deployer-rsync --save 提交搜素引擎 站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。Googlebot等搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。百度站长平台为未使用百度统计的站点提供三种验证方式：文件验证、html标签验证、CNAME验证，如果选择文件验证，下载文件后将文件放在source跟目录下。验证完成后，我们将会认为您是网站的拥有者。为使您的网站一直保持验证通过的状态，请保留验证的文件、html标签或CNAME记录，我们会去定期检查验证记录。 对谷歌和百度的插举例-&gt;打开博客根目录，在这个目录下打开终端执行执行如下两个安装插件：npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 在博客根目录的_config.yml中添加如下代码 12345# 自动生成sitemapsitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 执行hexo generate编译博客后，如果博客根目录的public下生成了sitemap.xml以及baidusitemap.xml就表示成功了。 生成静态文件 hexo generate 生成静态文件查看默认博客效果 hexo server （如果默认的4000端口被占用，可以使用-p参数指定其他端口，如：hexo server -p 5000） 修改配置 在站点的配置文件_config.yml中设置部署信息(注意：type repo branch message前有两个空格)12345deploy: type: git repo: https://github.com/eightplus/eightplus.github.io.git branch: master message: &apos;站点更新:&#123;&#123;now(&quot;YYYY-MM-DD HH:mm:ss&quot;)&#125;&#125;&apos; 部署到GitHub上12345hexo clean #清空hexo generate #生成静态网页hexo deploy #部署浏览器中输入 http://eightplus.github.io 绑定域名 在hexo的工作空间下的source目录下新建一个CNAME的文件，不要后缀。打开CNAME写上购买的域名，如： eightplus.info 扩展 网站访问量显示 使用第三方的统计插件不蒜子, 在themes\\yilia\\layout_partial下的footer.ejs中加入如下代码即可12345678&lt;script async src=&quot;//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;总访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次&lt;/span&gt; 实现单篇文章浏览统计和评论统计(从网易云跟帖中获取评论数) 参考文档 修改themes\\yilia\\layout_partial文件夹下的article.ejs文件，在&lt;%- partial(‘post/title’, {class_name: ‘article-title’}) %&gt;节点下加入(注意这里网易云跟帖还没设置，而评论数中使用到了，这里运行会有问题)显示阅读和评论数 -->1234567891011121314&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.wangYi)&#123; %&gt;&lt;br/&gt;&lt;a class=&quot;cloud-tie-join-count&quot; href=&quot;javascript:void(0);&quot; style=&quot;color:gray;font-size:14px;&quot;&gt;&lt;span class=&quot;icon-sort&quot;&gt;&lt;/span&gt;&lt;span id=&quot;busuanzi_container_page_pv&quot; style=&quot;color:#ef7522;font-size:14px;&quot;&gt; 阅读数: &lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次 &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;a class=&quot;cloud-tie-join-count&quot; href=&quot;javascript:void(0);&quot; style=&quot;color:#ef7522;font-size:14px;&quot;&gt; &lt;span class=&quot;icon-comment&quot;&gt;&lt;/span&gt; &lt;span class=&quot;join-text&quot; style=&quot;color:#ef7522;font-size:14px;&quot;&gt;评论数:&lt;/span&gt; &lt;span class=&quot;join-count&quot;&gt;0&lt;/span&gt;次&lt;/a&gt;&lt;% &#125; %&gt;","categories":[{"name":"工具","slug":"工具","permalink":"https://eightplus.github.io/categories/工具/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://eightplus.github.io/tags/Hexo/"}]},{"title":"Ubuntu下Android开发的基础知识","slug":"2018-07-03-build-android","date":"2018-07-03T03:01:16.000Z","updated":"2018-08-02T01:00:02.033Z","comments":true,"path":"2018/07/03/2018-07-03-build-android/","link":"","permalink":"https://eightplus.github.io/2018/07/03/2018-07-03-build-android/","excerpt":"","text":"这里使用Ubuntu 16.04的64位系统上进行Android源码的编译。 一、环境准备 安装ubuntu 16.04 amd64 系统 安装Git ~$ sudo apt-get install git-core gnupg 安装Java SDK(官方JDK下载地址：http://www.oracle.com/technetwork/java/javase/downloads/index.html)： $ sudo add-apt-repository “deb http://us.archive.ubuntu.com/ubuntu/ hardy multiverse” $ sudo apt-get update $ sudo apt-get install sun-java6-jre sun-java6-plugin $ sudo apt-get install sun-java6-jdk 安装其他依赖包(valgrind为调试工具) $ sudo apt-get install flex bison gperf libsdl-dev libesd0-dev libwxgtk2.6-dev build-essential zip curl valgrind 二、下载Android源码 下载repo工具 $ wget https://dl-ssl.google.com/dl/googlesource/git-repo/repo $ chmod a+x repo $ sudo mv repo /bin/ 下载Android源码 $ mkdir Android $ cd Android Android$ repo init -u https://android.googlesource.com/platform/mainifest(如果想下载Android 2.3.1，执行：repo init -u https://android.googlesource.com/platform/mainifest -b android-2.3.1_r1) Android$ repo sync 三、编译Android源码 Android$make (make -j18)编译结果的输出目录为out/target/product/$(TARGET_PRODUCT),TARGET_PRODUCT是一个环境变量，默认值为generic 四、编译SDK(可选) Android$make sdk打包成功后，可以看到如下输出($USER$表示当前登录的用户名)：1Package SDK: out/host/linux-x86/sdk/android-sdk_eng.$USER$_linux-x86.zip 五、安装编译好的Android镜像到模拟器上 设置环境变量(Android模拟器命令emulator位于Android/out/host/linux-x86/bin中，~/Android/out/target/product/generic是Android镜像存放目录) Android$export PATH=$PATH:~/Android/out/host/linux-x86/bin Android$export ANDROID_PRODUCT_OUT=~/Android/out/target/product/generic 运行Android模拟器 Android$emulator 启动Android模拟器需要四个文件，分别为zImage、system.img、userdata.img和ramdisk.img，其中zImage为Linux内核镜像文件，三个.img文件为Android系统镜像文件。如果不带任何参数来运行emulator命令，则Android模拟器默认使用的zImage文件是Android/out/host/linux-x86/bin中的kernel-qemu文件，默认使用的三个.img文件位于ANDROID_PRODUCT_OUT目录中。ANDROID_PRODUCT_OUT是一个环境变量，这里将它的值设置为Android源码编译结果的输出目录，如果不设置ANDROID_PRODUCT_OUT环境变量，就需要指定上述四个文件来启动Android模拟器，如下： Android$emulator - kernel ./prebuilt/android-arm/kernel/kernel-qemu -sysdir ./out/target/product/generic -system system.img -data userdata.img -ramdisk ramdisk.img 六、下载、编译和安装Android最新内核源代码Android源代码工程默认是不包括它所使用的Linux内核源代码的，而是使用预先编译好的内核，即prebuilt/android-arm/kernel/kernel-qemu文件。如果我们需要运行定制的Linux内核，则需要下载Linux kernel源代码进行编译。 Linux kernel源代码下载 ~/Android$ mkdir kernel ~/Android$ cd kernel ~/Android/kernel$ git clone http://android.googlesource.com/kernel/goldfish.git 支线下载下载完成后，在kernel目录下可以看到一个空的goldfish子目录，此时需要执行git checkout来指定需要的支线代码，在执行git checkout之前，可先执行git branch -a查看有哪些支线代码。这里选择android-gldfish-2.6.29 ~/Android/kernel/goldfish$git branch -a ~/Android/kernel/goldfish$git checkout remotes/origin/archive/android-gldfish-2.6.29 修改Android内核源码目录下Makefile文件中的CROSS_COMPILE变量 1234#ARCH ?= (SUBARCH)#CROSS_COMPILE ?=ARCH ?= arm #体系结构为armCROSS_COMPILE ?= arm-eabi- #交叉编译工具链前缀 将交叉编译工具目录添加到环境变量PATH中 ~/Android/kernel/goldfish$ export PATH=$PATH:~/Android/prebuilt/linux-x86/toolchain/arm-eabi-4.4.3/bin 修改硬件配置文件goldfish_defconfig ~/Android/kernel/goldfish$ make goldfish_defconfig 开始编译(在make之前，可以执行make menuconfig先配置一下编译选项) ~/Android/kernel/goldfish$ make编译成功后，可看到下面两行：12OBJCOPY arch/arm/boot/zImageKernel: arch/arm/boot/zImage is ready 七、在模拟器中运行编译好的内核 在启动模拟器之前，先设置模拟器的目录到环境变量$PATH中去 ~/Android$export PATH=$PATH:~/Android/out/host/linux-x86/bin 设置ANDROID_PRODUCT_OUT环境变量 ~/Android$export ANDROID_PRODUCT_OUT=~/Android/out/target/product/generic 在后台中指定内核文件启动模拟器 ~/Android$emulator -kernel ./kernel/goldfish/arch/arm/boot/zImage &amp; 用adb工具连接模拟器，查看内核版本信息，看看模拟器上跑的内核是不是刚才编译出来的内核(adb位于~/Android/out/host/linux-x86/bin目录中)123~/Android$ adb shellroot@android:/ # cd procroot@android:/proc # cat version 八、单独编译Android源代码中的模块Android源码第一次执行make会耗时很久，之后如果修改了Android源码中的某个模块或者在Android源码工程新增一个自己的模块，则可以单独编译该模块，以及重新打包system.img。 在Android源码目录下的build目录下，有个脚本文件envsetup.sh，执行这个脚本文件可以获得一些有用的工具，其中就包括mmm，该命令用来编译指定目录的所有模块，通常这个目录只包含一个模块。 使用mmm命令来编译指定的模块，如Email应用程序 ~/Android$mmm packages/apps/Email/编译完成之后，就可以在out/target/product/generic/system/app目录下看到Email.apk文件了。Android系统自带的App都放在这具目录下。另外，Android系统的一些可执行文件，例如C编译的可执行文件，放在out/target/product/generic/system/bin目录下，动态链接库文件放在out/target/product/generic/system/lib目录下，out/target/product/generic/system/lib/hw目录存放的是硬件抽象层（HAL）接口文件. 编译好模块后，重新打包system.img文件 ~/Android$make snod 运行模拟器： ~/Android$emulator 九、日志系统Android系统在用户空间中提供了轻量级的logger日志系统，它是在内核中实现的一种设备驱动，与用户空间的logcat工具配合使用能够方便地跟踪调试程序。在Android系统中，分别为C/C++ 和Java语言提供两种不同的logger访问接口。C/C++日志接口一般是在编写硬件抽象层模块或者编写JNI方法时使用，而Java接口一般是在应用层编写APP时使用。 Android系统中的C/C++日志接口是通过宏来使用的。在system/core/include/android/log.h定义了日志的级别, 在system/core/include/cutils/log.h中，定义了对应的宏，如对应于ANDROID_LOG_VERBOSE的宏LOGV。如果使用C/C++日志接口，只要定义自己的LOG_TAG宏和包含头文件system/core/include/cutils/log.h就可以了。12#define LOG_TAG &quot;MY LOG TAG&quot;#include &lt;cutils/log.h&gt; 就可以了，例如使用LOGV：LOGV(“This is the log printed by LOGV in android user space.”);//ALOGI Android系统在Frameworks层中定义了Java日志接口（frameworks/base/core/java/android/util/Log.java）如果使用Java日志接口，只要在类中定义的LOG_TAG常量和引用android.util.Log就可以了。12private static final String LOG_TAG = &quot;MY_LOG_TAG&quot;;Log.i(LOG_TAG, &quot;This is the log printed by Log.i in android user space.&quot;); 要查看这些LOG的输出，可以配合logcat工具 如果是在自己编译的Android源代码工程中使用，则在后台中运行模拟器 ~/Android$ emulator &amp; 启动adb shell工具 ~/Android$ adb shell 使用logcat命令查看日志 root@android:/ # logcat","categories":[{"name":"工具","slug":"工具","permalink":"https://eightplus.github.io/categories/工具/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://eightplus.github.io/tags/Android/"}]},{"title":"ubuntu snap 应用","slug":"2018-06-29-snap-qt-dbus","date":"2018-06-29T02:58:12.000Z","updated":"2018-07-31T09:54:47.030Z","comments":true,"path":"2018/06/29/2018-06-29-snap-qt-dbus/","link":"","permalink":"https://eightplus.github.io/2018/06/29/2018-06-29-snap-qt-dbus/","excerpt":"","text":"Ubuntu 从 16.04开始，支持两种格式的安装包：debian 和 snap，其中 snap 不依赖于操作系统及其发布版本， 其可以安装同样一个软件的不同版本且不造成任何的干扰。snap 是一种全新的软件包管理方式，它类似一个容器拥有一个应用程序所有的文件和库，各个应用程序之间完全独立，解决了应用程序之间的依赖问题，但因其包含应用需要的文件和库，导致snap包过大，占用更多的磁盘空间（snap包包含一个私有的root文件系统，里面包含了依赖的软件包）。 Snap命令简介 安装Snap的相关包 sudo apt update sudo apt-get install snapd snapcraft build-essential 在snap store中查找snap包 snap find 显示已安装的snap应用列表 snap list 安装一个snap包 sudo snap install &lt;snap_pkg_name&gt; 更新一个snap包 sudo snap refresh &lt;snap_pkg_name&gt; 将snap包还原到以前安装的版本 sudo snap revert &lt;snap_pkg_name&gt; 卸载一个snap包 sudo snap remove &lt;snap_pkg_name&gt; 打造Snap应用 我这里配置的system dbus相关的.service和.conf文件根本在snap包中没有起到作用，debian包中是可以的，原因暂时没找到比较官方的答案。最终使用plug和slot的方式，并且是手动启动system dbus的方法才让图形程序从dbus daemon获取到数据（貌似是目前snap还不支持dbus的自动启动？？？）。 1、编码编写完毕后，在源码第一级目录下打开终端，执行：$snapcraft init，会自动生成snap相关文件，其中模板文件snapcraft.yaml将描述snap包的整个构建过程 2、修改模板文件snapcraft.yaml，具体见源码中的写法 3、终端执行：$snapcraft ，生成snap包 4、安装snap包：$sudo snap install system-tool_1.0.2_amd64.snap –devmode –dangerous 5、安装完成后，终端运行 $snap interfaces 可以查看到plug和slot。有资料显示，如果要让我的dbus服务程序和图形程序进行通信，还需要终端执行：$sudo snap connect system-tool:daemon-plug system-tool:daemon-slot ，对应的disconnect操作是：$sudo snap disconnect system-tool:daemon-plug system-tool:daemon-slot。此处不执行上述操作仍可以，有些不知所依然？？？可能是我这里在snap容器中关于dbus的使用方法没找到正解的原因。 6、手动启动dbus服务，打开终端执行：$sudo system-tool.system-tool-daemon 7、启动图形程序：$system-tool图形程序运行结果图 8、如果想将自己开发的snap发布到snap商店，首先注册一个Ubuntu One帐号，注册地址 9、有了帐号之后，自然是一条流水线生产操作步骤：登录-&gt;注册应用名-&gt;上传snap包-&gt;退出 snapcraft login snapcraft register system-tool (只有第一次上传该应用时才需要注册应用名) snapcraft push system-tool_1.0.2_amd64.snap –release beta snapcraft logout 10、上传后，你可以在邮箱等着snapcraft系统给你回邮件啦！很遗憾，由于我使用了自定义的plug和slot，自动审核失败了，需要人工审核（之前验证过没有自定义slot和plug时，上传可以自动审核成功）。 参考文档https://forum.snapcraft.io/t/the-dbus-interface/2038 https://github.com/snapcore/snapd/wiki/Interfaces#dbus https://forum.snapcraft.io/t/how-do-i-connect-a-snap-to-dbus/1533 https://github.com/snapcore/snapd/pull/2592 https://blog.csdn.net/tq08g2z/article/details/78685011 https://www.2cto.com/kf/201607/528337.html https://blog.csdn.net/ubuntutouch/article/details/51886345 https://blog.csdn.net/ubuntutouch/article/details/51953272 https://www.msweet.org/blog/2018-01-23-snaps-and-gui-apps.html https://github.com/ubuntu/snappy-playpen https://code.launchpad.net/~dpm/ubuntu-calendar-app/snap-all-things","categories":[{"name":"工具","slug":"工具","permalink":"https://eightplus.github.io/categories/工具/"}],"tags":[{"name":"Snap","slug":"Snap","permalink":"https://eightplus.github.io/tags/Snap/"}]},{"title":"使用Jekyll + Github搭建博客","slug":"2018-06-27-welcome-to-jekyll","date":"2018-06-27T07:33:17.000Z","updated":"2018-08-02T01:37:44.162Z","comments":true,"path":"2018/06/27/2018-06-27-welcome-to-jekyll/","link":"","permalink":"https://eightplus.github.io/2018/06/27/2018-06-27-welcome-to-jekyll/","excerpt":"","text":"一直想把自己学习linux的过程记录下来，又不想总是依托那些现成的博客网站，在WordPress和Github中，我选择了Github，原因只有一个，穷，哈哈哈。这里先简要接收博客搭建的初期准备工作！Markdown编辑器使用的是Atom，快捷键列表如下： 快捷键 解释 Crtl+Shift+M 开启Markdown实时预览 Command+Shift+P 打开命令窗口，可以运行各种菜单功能 Command + T 快速多文件切换 Command + F 文件内查找和替换 Command + Shift + F 多文件查找和替换 Command + [ 对选中内容向左缩进 Command + ] 对选中内容向右缩进 Command + \\ 显示或隐藏目录树 Crtl + m 相应括号之间，html tag之间等跳转 Crtl + Alt + B 格式化代码（需要安装atom-beautify） Crtl + ` 调起CLI命令行界面（需要安装terminal-panel） Github github帐号注册和创建页面仓库 注册地址：https://github.com/ 仓库的名字需要和你的账号对应，格式：yourname.github.io，比如我这里演示的页面仓库名为eightplus.github.io 生成ssh密钥，并将密钥添加到github上 生成密钥：ssh-keygen -t rsa -C 注册帐号时的邮箱地址” 密钥生成后，在 ~/.ssh目录下会生成一些文件，包括id_rsa和id_rsa.pub 打开id_rsa.pub，选中所有内容复制，网页进入 https://github.com/settings/ssh ，Add SSH key，粘贴之前复制的内容。 Github安装和帐号配置 sudo apt-get install git git config --global user.name &quot;yourname&quot; git config --global user.email &quot;注册帐号时的邮箱地址&quot; 安装ruby环境sudo apt-get install ruby-all-dev我的系统为Ubuntu 16.04，使用的软件源里面存在ruby2.3-dev，则此种方式会将ruby2.3-dev一并安装，当然，上述操作也可以替换成安装ruby2.3-dev，(sudo apt-get install ruby2.3-dev) 安装完成后，在终端中输入ruby -v，查看版本信息，如下图： 完成ruby环境后，在终端中输入gem -v，出现如下结果，则说明ruby环境已经完全配置成功了，如果出现了报错信息，可能需要安装nodejs (sudo apt-get install nodejs)。 安装JeKyll环境 先安装依赖包bundler： sudo gem install bundler 再安装安装jekyll： sudo gem install jekyll 安装完成后，在终端中输入jekyll --version，出现如下结果，则说明安装成功 工程创建是否迫不及待的想看下第一个博客的具体内容 👉 在你打算存放工程代码的目录下打开一个终端后使用jekyll创建一个项目，这里我的目录为：~/work/git/：jekyll new blog操作之后会生成很多文件/文件夹，详细说明如下： _config.yml：Jekyll配置文件，存储配置数据 _drafts：草稿目录，可手动创建 _includes：包含一些模板，可以重复利用 _layouts：存放页面模板的地方 _posts：存放文章的目录，文章格式为 mardown 格式（year-month-title.markdown）或.md，文件名确定了发表的日期和标记语言 _data：存放yaml格式的数据文件 _site：使用Jekyll编译后的静态站点将存放于这个目录下，即jekyll生成的网站会放在该文件夹下，该目录不需要push到github，可在.gitignore文件中加入这个目录 index.html：该文件带有 yaml 头信息，大概如下：123456---layout: posttitle: &quot;Welcome to Jekyll!&quot;date: 2018-06-27 15:33:17 +0800categories: jekyll update--- 上述操作会生成个默认文章，位于_posts目录下，名字类似为：2018-06-27-welcome-to-jekyll.markdown 可以复制2018-06-27-welcome-to-jekyll.markdown后进行修改来进行新的博客编写，这里推荐使用 git的atom编辑器 来编辑.markdown文件，可以在atom官网进行deb包的下载，新页面生成和编辑完成后，重启jekyll内置服务器（终端执行：jekyll serve），打开或刷新页面：http://localhost:4000，这样就可以在页面看到自己添加的博文了。 Git同步将前面创建的仓库克隆到本地，然后将blog目录中生成的文件复制到github项目目录下，我这里项目名为 eightplus.github.io。 git clone https://github.com/yourname/yourname.github.io.git git add . git commit -m &quot;init&quot; git push -u origin master 至此，在浏览器中输入https://yourname.github.io，比如：https://eightplus.github.io/，即可看到下图，博客搭建完成 网页浏览效果图","categories":[{"name":"工具","slug":"工具","permalink":"https://eightplus.github.io/categories/工具/"}],"tags":[{"name":"Jekyll","slug":"Jekyll","permalink":"https://eightplus.github.io/tags/Jekyll/"}]}]}