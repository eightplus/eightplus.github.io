<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eight Plus</title>
  
  <subtitle>菜鸟的点滴记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://eightplus.github.io/"/>
  <updated>2020-05-20T07:02:25.756Z</updated>
  <id>https://eightplus.github.io/</id>
  
  <author>
    <name>李翔</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>stdin 输入</title>
    <link href="https://eightplus.github.io/2020/05/05/2020-05-05-stdin/"/>
    <id>https://eightplus.github.io/2020/05/05/2020-05-05-stdin/</id>
    <published>2020-05-05T13:38:59.000Z</published>
    <updated>2020-05-20T07:02:25.756Z</updated>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;使用 C 和 Qt 监控用户的终端输入(stdin)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;示例源码&quot;&gt;&lt;a href=&quot;#示例源码&quot; class=&quot;headerlink&quot; title=&quot;示例源码&quot;&gt;&lt;/a&gt;示例源码&lt;/h
      
    
    </summary>
    
      <category term="Linux 编程" scheme="https://eightplus.github.io/categories/Linux-%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Qt C" scheme="https://eightplus.github.io/tags/Qt-C/"/>
    
  </entry>
  
  <entry>
    <title>GtkApplication 编程示例</title>
    <link href="https://eightplus.github.io/2020/04/13/2020-04-13-GtkApplication/"/>
    <id>https://eightplus.github.io/2020/04/13/2020-04-13-GtkApplication/</id>
    <published>2020-04-13T15:26:52.000Z</published>
    <updated>2020-05-06T07:27:50.975Z</updated>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;GtkApplication可以让我们的核心程序代码与main()函数分开，这样可以让main()简单化，里面只需要创建GtkApplication对象并运行它，而其他图形相关的操作则在GtkApplication发出的信号中完成。GtkAppli
      
    
    </summary>
    
      <category term="Linux 编程" scheme="https://eightplus.github.io/categories/Linux-%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="GTK" scheme="https://eightplus.github.io/tags/GTK/"/>
    
  </entry>
  
  <entry>
    <title>Qt 笔记</title>
    <link href="https://eightplus.github.io/2020/02/03/2020-02-03-Qt-notes/"/>
    <id>https://eightplus.github.io/2020/02/03/2020-02-03-Qt-notes/</id>
    <published>2020-02-03T03:06:18.000Z</published>
    <updated>2020-02-08T04:53:01.524Z</updated>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;好记性不如烂笔头，记录一些Qt学习过程中的笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;1-遍历所有session-dbus的服务名和接口名的参考方法&quot;&gt;&lt;a href=&quot;#1-遍历所有session-dbus的服务名和接口
      
    
    </summary>
    
      <category term="Linux 编程" scheme="https://eightplus.github.io/categories/Linux-%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Qt" scheme="https://eightplus.github.io/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>X11进行窗口状态设置</title>
    <link href="https://eightplus.github.io/2020/01/13/2020-01-13-windowstate/"/>
    <id>https://eightplus.github.io/2020/01/13/2020-01-13-windowstate/</id>
    <published>2020-01-13T13:49:40.000Z</published>
    <updated>2020-01-13T14:10:31.833Z</updated>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在Qt的编程中，我们可以很方便的使用QWidget的一些属性和槽函数来进行窗口状态设置，比如&lt;code&gt;setWindowFlags(windowFlags() | Qt::WindowStaysOnTopHint)&lt;/code&gt;可以设置窗口置顶，
      
    
    </summary>
    
      <category term="Linux 编程" scheme="https://eightplus.github.io/categories/Linux-%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Qt X11" scheme="https://eightplus.github.io/tags/Qt-X11/"/>
    
  </entry>
  
  <entry>
    <title>鼠标点击穿透</title>
    <link href="https://eightplus.github.io/2020/01/12/2020-01-12-inputpass/"/>
    <id>https://eightplus.github.io/2020/01/12/2020-01-12-inputpass/</id>
    <published>2020-01-12T04:39:05.000Z</published>
    <updated>2020-01-13T13:51:25.537Z</updated>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;鼠标点击穿透，即所有鼠标键盘操作全部会穿透窗口到下方窗口。在Linux下，Qt的Qt::WA_TransparentForMouseEvents属性可以对子部件实现鼠标穿透，但是对整个窗口不行，要想在Linux下对Qt的整个窗口设置鼠标穿透，这时候
      
    
    </summary>
    
      <category term="Linux 编程" scheme="https://eightplus.github.io/categories/Linux-%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Qt X11" scheme="https://eightplus.github.io/tags/Qt-X11/"/>
    
  </entry>
  
  <entry>
    <title>Desktop Notification 消息框</title>
    <link href="https://eightplus.github.io/2019/12/26/2019-12-26-notification/"/>
    <id>https://eightplus.github.io/2019/12/26/2019-12-26-notification/</id>
    <published>2019-12-26T13:42:11.000Z</published>
    <updated>2020-04-13T15:45:14.522Z</updated>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在Ubuntu系统上，我们经常可以看到如下图所示的消息框(Desktop Notification)，比如电池电量提醒和邮件消息提醒，通过调用org.freedesktop.Notifications这个DBUS服务提供的接口即可在桌面上弹出该消息
      
    
    </summary>
    
      <category term="Linux 编程" scheme="https://eightplus.github.io/categories/Linux-%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Qt" scheme="https://eightplus.github.io/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Qt多线程之QtConcurrent::map()</title>
    <link href="https://eightplus.github.io/2019/11/15/2019-11-15-qtconcurrent-map/"/>
    <id>https://eightplus.github.io/2019/11/15/2019-11-15-qtconcurrent-map/</id>
    <published>2019-11-15T07:53:10.000Z</published>
    <updated>2019-11-15T08:10:20.597Z</updated>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;QtConcurrent::map()、QtConcurrent::mapped()和QtConcurrent::mappedReduced()函数可以对一个序列中（如QList、QVector等）的项目并行地进行计算。&lt;/p&gt;
&lt;/blockqu
      
    
    </summary>
    
      <category term="Linux 编程" scheme="https://eightplus.github.io/categories/Linux-%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Qt" scheme="https://eightplus.github.io/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Qt多线程之QtConcurrent::run()</title>
    <link href="https://eightplus.github.io/2019/11/13/2019-11-13-qtconcurrent-run/"/>
    <id>https://eightplus.github.io/2019/11/13/2019-11-13-qtconcurrent-run/</id>
    <published>2019-11-13T12:14:36.000Z</published>
    <updated>2019-11-13T12:27:23.802Z</updated>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;前面两篇文章，我们介绍了QThread多线程的使用方法，今天开始介绍QtConcurrent，QtConcurrent是一个名字空间, 包含了众多的高级API, 方便用户编写多线程程序，且不需要使用低级线程原语(如:互斥、读写锁、等待条件或信号量)
      
    
    </summary>
    
      <category term="Linux 编程" scheme="https://eightplus.github.io/categories/Linux-%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Qt" scheme="https://eightplus.github.io/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Qt多线程之子类化QObject</title>
    <link href="https://eightplus.github.io/2019/11/11/2019-11-11-qthread-object/"/>
    <id>https://eightplus.github.io/2019/11/11/2019-11-11-qthread-object/</id>
    <published>2019-11-11T08:43:21.000Z</published>
    <updated>2019-11-11T08:44:36.171Z</updated>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;上一篇文章讲述了子类化QThread，并重新实现run()函数，这篇文章将讲述多线程之定义工作对象继承自QObject，然后把这个工作对象move到QThread的一个对象中（moveToThread(QThread * thread)函数将工作类
      
    
    </summary>
    
      <category term="Linux 编程" scheme="https://eightplus.github.io/categories/Linux-%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Qt" scheme="https://eightplus.github.io/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Qt多线程之子类化QThread</title>
    <link href="https://eightplus.github.io/2019/11/10/2019-11-10-qthread-run/"/>
    <id>https://eightplus.github.io/2019/11/10/2019-11-10-qthread-run/</id>
    <published>2019-11-10T07:28:40.000Z</published>
    <updated>2019-11-10T08:09:32.154Z</updated>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Qt中提供了对于线程的支持，它提供了一些独立于平台的线程类QThread，要使用QThread进行多线程编程，有两种方式。一是子类化QThread，并重新实现run()函数；二是定义工作对象继承自QObject，然后把这个工作对象move到QThr
      
    
    </summary>
    
      <category term="Linux 编程" scheme="https://eightplus.github.io/categories/Linux-%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Qt" scheme="https://eightplus.github.io/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Qt配置文件之QGSettings</title>
    <link href="https://eightplus.github.io/2019/11/07/2019-11-07-qgsettings/"/>
    <id>https://eightplus.github.io/2019/11/07/2019-11-07-qgsettings/</id>
    <published>2019-11-07T08:05:18.000Z</published>
    <updated>2020-04-13T15:45:06.410Z</updated>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文介绍使用dconf作为后端的GSetting用法，dconf是一个简单的底层配置存储管理系统，可以使用图形化的dconf-editor根据path来检索GSettings并管理key，而且支持在key发生改变时发出通知(changed信号)。命
      
    
    </summary>
    
      <category term="Linux 编程" scheme="https://eightplus.github.io/categories/Linux-%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Qt" scheme="https://eightplus.github.io/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Qt配置文件之QSettings</title>
    <link href="https://eightplus.github.io/2019/11/06/2019-11-06-qsettings/"/>
    <id>https://eightplus.github.io/2019/11/06/2019-11-06-qsettings/</id>
    <published>2019-11-06T01:30:05.000Z</published>
    <updated>2019-11-10T07:55:27.043Z</updated>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在用Qt编程时，很多时候需要在本地保留用户的配置，方便下次启动程序的时候使用上次的配置数据，这里推荐使用QSettings读写配置文件（QSettings可重入，即可以同时在不同的线程中使用不同的QSettings对象），而不是去用数据库去记录和读
      
    
    </summary>
    
      <category term="Linux 编程" scheme="https://eightplus.github.io/categories/Linux-%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Qt" scheme="https://eightplus.github.io/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>通过boost.python将c++封装成动态库供python调用</title>
    <link href="https://eightplus.github.io/2019/10/22/2019-10-22-boost-python-cpp/"/>
    <id>https://eightplus.github.io/2019/10/22/2019-10-22-boost-python-cpp/</id>
    <published>2019-10-22T15:10:10.000Z</published>
    <updated>2019-10-22T15:23:38.700Z</updated>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这里简要介绍如何通过boost.python将c++封装动态库，让python直接调用库中的函数，要做到这一点，我们需要让so中将要在python中直接调用的函数、类、结构体等，通过boost中特定函数暴露给python，而且so的目标名必须和BO
      
    
    </summary>
    
      <category term="Linux 编程" scheme="https://eightplus.github.io/categories/Linux-%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Boost Python C++" scheme="https://eightplus.github.io/tags/Boost-Python-C/"/>
    
  </entry>
  
  <entry>
    <title>Boost 序列化</title>
    <link href="https://eightplus.github.io/2019/09/18/2019-09-18-boost-serialization/"/>
    <id>https://eightplus.github.io/2019/09/18/2019-09-18-boost-serialization/</id>
    <published>2019-09-18T02:58:18.000Z</published>
    <updated>2019-09-18T03:37:16.703Z</updated>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;上一篇博客讲解过 protobuf 的序列化（将对象变成字节流的形式传出去）和反序列化（从字节流恢复成原来的对象），这篇博客将介绍另外一种序列化和反序列化的方案：Boost.Serialization。Boost.Serialization可以创建
      
    
    </summary>
    
      <category term="Linux 编程" scheme="https://eightplus.github.io/categories/Linux-%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Boost" scheme="https://eightplus.github.io/tags/Boost/"/>
    
  </entry>
  
  <entry>
    <title>protobuf</title>
    <link href="https://eightplus.github.io/2019/09/11/2019-09-11-protobuf/"/>
    <id>https://eightplus.github.io/2019/09/11/2019-09-11-protobuf/</id>
    <published>2019-09-11T13:07:14.000Z</published>
    <updated>2019-09-11T13:40:15.178Z</updated>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Protobuf: Google Protocol Buffer，是 Google 公司内部的混合语言数据标准，用于 RPC 系统和持续数据存储系统。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;proto3-与-proto2-的
      
    
    </summary>
    
      <category term="Linux 编程" scheme="https://eightplus.github.io/categories/Linux-%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="protobuf" scheme="https://eightplus.github.io/tags/protobuf/"/>
    
  </entry>
  
  <entry>
    <title>回调函数</title>
    <link href="https://eightplus.github.io/2019/09/05/2019-09-05-callback/"/>
    <id>https://eightplus.github.io/2019/09/05/2019-09-05-callback/</id>
    <published>2019-09-05T11:18:07.000Z</published>
    <updated>2019-09-05T11:36:28.220Z</updated>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么学会写回调函数很重要？&quot;&gt;&lt;a href=&quot;#为什么学会写回调函数很重要？&quot; class=&quot;headerlink&quot; title=&quot;为什么学会写回调函数很重要？&quot;&gt;&lt;/a&gt;为什么学会写回调函数很重要？&lt;/h2&gt;&lt;p&gt;  假设有两个程序，程序A为上层应用程序，程
      
    
    </summary>
    
      <category term="Linux 编程" scheme="https://eightplus.github.io/categories/Linux-%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="callback" scheme="https://eightplus.github.io/tags/callback/"/>
    
  </entry>
  
  <entry>
    <title>Gtk plugin 编程开发</title>
    <link href="https://eightplus.github.io/2019/09/01/2019-09-01-gtk-plugins/"/>
    <id>https://eightplus.github.io/2019/09/01/2019-09-01-gtk-plugins/</id>
    <published>2019-09-01T04:02:13.000Z</published>
    <updated>2019-09-01T04:34:33.592Z</updated>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;前面介绍过GLib、GObject和Dbus-glib，这里将在这些知识的基础上，结合Gtk图形库，完成一个插件（plugin）框架的搭建。该怎么通俗易懂的介绍这里的插件呢，左思右想，还是决定以GStreamer为例来简单介绍下插件（GStream
      
    
    </summary>
    
      <category term="Linux 编程" scheme="https://eightplus.github.io/categories/Linux-%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Gtk GLib GObject" scheme="https://eightplus.github.io/tags/Gtk-GLib-GObject/"/>
    
  </entry>
  
  <entry>
    <title>GObject 编程入门</title>
    <link href="https://eightplus.github.io/2019/08/30/2019-08-30-gobject-demo/"/>
    <id>https://eightplus.github.io/2019/08/30/2019-08-30-gobject-demo/</id>
    <published>2019-08-30T12:50:27.000Z</published>
    <updated>2019-08-30T14:15:05.077Z</updated>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Gobject，也称Glib对象系统，是一个程序库，它可以帮助我们使用C语言编写面向对象程序，其提供了一个通用的动态类型系统（GType）、一个基本类型的实现集（如整型、枚举等）、一个基本对象类型Gobject、一个信号系统以及一个可扩展的参数/变
      
    
    </summary>
    
      <category term="Linux 编程" scheme="https://eightplus.github.io/categories/Linux-%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Glib GObject" scheme="https://eightplus.github.io/tags/Glib-GObject/"/>
    
  </entry>
  
  <entry>
    <title>Dbus-glib</title>
    <link href="https://eightplus.github.io/2019/08/27/2019-08-27-dbus-glib/"/>
    <id>https://eightplus.github.io/2019/08/27/2019-08-27-dbus-glib/</id>
    <published>2019-08-27T00:19:31.000Z</published>
    <updated>2019-08-27T16:06:34.716Z</updated>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;如果你想在Linux系统下开发软件，且需要用到进程间通信时，我强烈建议你了解和使用Dbus。Dbus是实质上一个适用于桌面应用的进程间的通讯机制，即所谓的IPC机制。Dbus是一个进程间的通信机制，可以是应用与应用之间的通信，也可以是应用与系统之间
      
    
    </summary>
    
      <category term="Linux 编程" scheme="https://eightplus.github.io/categories/Linux-%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Dbus" scheme="https://eightplus.github.io/tags/Dbus/"/>
    
  </entry>
  
  <entry>
    <title>使用mpv编写自己的播放器</title>
    <link href="https://eightplus.github.io/2019/08/19/2019-08-19-qt-mpv-player/"/>
    <id>https://eightplus.github.io/2019/08/19/2019-08-19-qt-mpv-player/</id>
    <published>2019-08-19T07:32:08.000Z</published>
    <updated>2019-08-19T07:49:44.292Z</updated>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;MPV 是一个基于 MPlayer 和 MPlayer2 的多平台开源播放器，其在Linux上拥有广泛的输出设备支持，内置ffmpeg解码器，支持绝大部分的视频和音频格式，支持本地播放和网络播放，支持ass特效字幕，GPU 解码能力十分出色。虽然M
      
    
    </summary>
    
      <category term="Linux Qt 开发" scheme="https://eightplus.github.io/categories/Linux-Qt-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Qt" scheme="https://eightplus.github.io/tags/Qt/"/>
    
  </entry>
  
</feed>
